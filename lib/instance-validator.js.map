{
  "version": 3,
  "sources": ["../src/instance-validator.js"],
  "sourcesContent": ["'use strict';\r\n\r\nconst _ = require('lodash');\r\nconst Utils = require('./utils');\r\nconst sequelizeError = require('./errors');\r\nconst DataTypes = require('./data-types');\r\nconst { BelongsTo } = require('./associations/belongs-to');\r\nconst validator = require('./utils/validator-extras').validator;\r\nconst { promisify } = require('util');\r\n\r\n/**\r\n * Instance Validator.\r\n *\r\n * @param {Instance} modelInstance The model instance.\r\n * @param {object} options A dictionary with options.\r\n *\r\n * @private\r\n */\r\nexport class InstanceValidator {\r\n  constructor(modelInstance, options) {\r\n    options = {\r\n      // assign defined and default options\r\n      hooks: true,\r\n      ...options,\r\n    };\r\n\r\n    if (options.fields && !options.skip) {\r\n      options.skip = _.difference(Object.keys(modelInstance.constructor.rawAttributes), options.fields);\r\n    } else {\r\n      options.skip = options.skip || [];\r\n    }\r\n\r\n    this.options = options;\r\n\r\n    this.modelInstance = modelInstance;\r\n\r\n    /**\r\n     * Exposes a reference to validator.js. This allows you to add custom validations using `validator.extend`\r\n     *\r\n     * @name validator\r\n     * @private\r\n     */\r\n    this.validator = validator;\r\n\r\n    /**\r\n     *  All errors will be stored here from the validations.\r\n     *\r\n     * @type {Array} Will contain keys that correspond to attributes which will\r\n     *   be Arrays of Errors.\r\n     * @private\r\n     */\r\n    this.errors = [];\r\n\r\n    /**\r\n     * @type {boolean} Indicates if validations are in progress\r\n     * @private\r\n     */\r\n    this.inProgress = false;\r\n  }\r\n\r\n  /**\r\n   * The main entry point for the Validation module, invoke to start the dance.\r\n   *\r\n   * @returns {Promise}\r\n   * @private\r\n   */\r\n  async _validate() {\r\n    if (this.inProgress) {\r\n      throw new Error('Validations already in progress.');\r\n    }\r\n\r\n    this.inProgress = true;\r\n\r\n    await Promise.all([\r\n      this._perAttributeValidators(),\r\n      this._customValidators(),\r\n    ]);\r\n\r\n    if (this.errors.length > 0) {\r\n      throw new sequelizeError.ValidationError(null, this.errors);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Invoke the Validation sequence and run validation hooks if defined\r\n   *   - Before Validation Model Hooks\r\n   *   - Validation\r\n   *   - On validation success: After Validation Model Hooks\r\n   *   - On validation failure: Validation Failed Model Hooks\r\n   *\r\n   * @returns {Promise}\r\n   * @private\r\n   */\r\n  async validate() {\r\n    return await (this.options.hooks ? this._validateAndRunHooks() : this._validate());\r\n  }\r\n\r\n  /**\r\n   * Invoke the Validation sequence and run hooks\r\n   *   - Before Validation Model Hooks\r\n   *   - Validation\r\n   *   - On validation success: After Validation Model Hooks\r\n   *   - On validation failure: Validation Failed Model Hooks\r\n   *\r\n   * @returns {Promise}\r\n   * @private\r\n   */\r\n  async _validateAndRunHooks() {\r\n    const runHooks = this.modelInstance.constructor.runHooks.bind(this.modelInstance.constructor);\r\n    await runHooks('beforeValidate', this.modelInstance, this.options);\r\n\r\n    try {\r\n      await this._validate();\r\n    } catch (error) {\r\n      const newError = await runHooks('validationFailed', this.modelInstance, this.options, error);\r\n      throw newError || error;\r\n    }\r\n\r\n    await runHooks('afterValidate', this.modelInstance, this.options);\r\n\r\n    return this.modelInstance;\r\n  }\r\n\r\n  /**\r\n   * Will run all the validators defined per attribute (built-in validators and custom validators)\r\n   *\r\n   * @returns {Promise<Array>}\r\n   * @private\r\n   */\r\n  async _perAttributeValidators() {\r\n    // promisify all attribute invocations\r\n    const validators = [];\r\n\r\n    _.forIn(this.modelInstance.rawAttributes, (rawAttribute, field) => {\r\n      if (this.options.skip.includes(field)) {\r\n        return;\r\n      }\r\n\r\n      const value = this.modelInstance.dataValues[field];\r\n\r\n      if (value instanceof Utils.SequelizeMethod) {\r\n        return;\r\n      }\r\n\r\n      if (!rawAttribute._autoGenerated && !rawAttribute.autoIncrement) {\r\n        // perform validations based on schema\r\n        this._validateSchema(rawAttribute, field, value);\r\n      }\r\n\r\n      if (Object.prototype.hasOwnProperty.call(this.modelInstance.validators, field)) {\r\n        validators.push(this._singleAttrValidate(value, field, rawAttribute.allowNull));\r\n      }\r\n    });\r\n\r\n    return await Promise.all(validators);\r\n  }\r\n\r\n  /**\r\n   * Will run all the custom validators defined in the model's options.\r\n   *\r\n   * @returns {Promise<Array>}\r\n   * @private\r\n   */\r\n  async _customValidators() {\r\n    const validators = [];\r\n    _.each(this.modelInstance.constructor.options.validate, (validator, validatorType) => {\r\n      if (this.options.skip.includes(validatorType)) {\r\n        return;\r\n      }\r\n\r\n      const valprom = this._invokeCustomValidator(validator, validatorType)\r\n        // errors are handled in settling, stub this\r\n        .catch(() => {});\r\n\r\n      validators.push(valprom);\r\n    });\r\n\r\n    return await Promise.all(validators);\r\n  }\r\n\r\n  /**\r\n   * Validate a single attribute with all the defined built-in validators and custom validators.\r\n   *\r\n   * @private\r\n   *\r\n   * @param {*} value Anything.\r\n   * @param {string} field The field name.\r\n   * @param {boolean} allowNull Whether or not the schema allows null values\r\n   *\r\n   * @returns {Promise} A promise, will always resolve, auto populates error on this.error local object.\r\n   */\r\n  async _singleAttrValidate(value, field, allowNull) {\r\n    // If value is null and allowNull is false, no validators should run (see #9143)\r\n    if ((value === null || value === undefined) && !allowNull) {\r\n      // The schema validator (_validateSchema) has already generated the validation error. Nothing to do here.\r\n      return;\r\n    }\r\n\r\n    // Promisify each validator\r\n    const validators = [];\r\n    _.forIn(this.modelInstance.validators[field], (test, validatorType) => {\r\n\r\n      if (['isUrl', 'isURL', 'isEmail'].includes(validatorType)) {\r\n        // Preserve backwards compat. Validator.js now expects the second param to isURL and isEmail to be an object\r\n        if (typeof test === 'object' && test !== null && test.msg) {\r\n          test = {\r\n            msg: test.msg,\r\n          };\r\n        } else if (test === true) {\r\n          test = {};\r\n        }\r\n      }\r\n\r\n      // Custom validators should always run, except if value is null and allowNull is false (see #9143)\r\n      if (typeof test === 'function') {\r\n        validators.push(this._invokeCustomValidator(test, validatorType, true, value, field));\r\n\r\n        return;\r\n      }\r\n\r\n      // If value is null, built-in validators should not run (only custom validators have to run) (see #9134).\r\n      if (value === null || value === undefined) {\r\n        return;\r\n      }\r\n\r\n      const validatorPromise = this._invokeBuiltinValidator(value, test, validatorType, field);\r\n      // errors are handled in settling, stub this\r\n      validatorPromise.catch(() => {});\r\n      validators.push(validatorPromise);\r\n    });\r\n\r\n    return Promise\r\n      .all(validators.map(validator => validator.catch(error => {\r\n        const isBuiltIn = Boolean(error.validatorName);\r\n        this._pushError(isBuiltIn, field, error, value, error.validatorName, error.validatorArgs);\r\n      })));\r\n  }\r\n\r\n  /**\r\n   * Prepare and invoke a custom validator.\r\n   *\r\n   * @private\r\n   *\r\n   * @param {Function} validator The custom validator.\r\n   * @param {string} validatorType the custom validator type (name).\r\n   * @param {boolean} optAttrDefined Set to true if custom validator was defined from the attribute\r\n   * @param {*} optValue value for attribute\r\n   * @param {string} optField field for attribute\r\n   *\r\n   * @returns {Promise} A promise.\r\n   */\r\n  async _invokeCustomValidator(validator, validatorType, optAttrDefined, optValue, optField) {\r\n    let isAsync = false;\r\n\r\n    const validatorArity = validator.length;\r\n    // check if validator is async and requires a callback\r\n    let asyncArity = 1;\r\n    let errorKey = validatorType;\r\n    let invokeArgs;\r\n    if (optAttrDefined) {\r\n      asyncArity = 2;\r\n      invokeArgs = optValue;\r\n      errorKey = optField;\r\n    }\r\n\r\n    if (validatorArity === asyncArity) {\r\n      isAsync = true;\r\n    }\r\n\r\n    if (isAsync) {\r\n      try {\r\n        if (optAttrDefined) {\r\n          return await promisify(validator.bind(this.modelInstance, invokeArgs))();\r\n        }\r\n\r\n        return await promisify(validator.bind(this.modelInstance))();\r\n      } catch (error) {\r\n        return this._pushError(false, errorKey, error, optValue, validatorType);\r\n      }\r\n    }\r\n\r\n    try {\r\n      return await validator.call(this.modelInstance, invokeArgs);\r\n    } catch (error) {\r\n      return this._pushError(false, errorKey, error, optValue, validatorType);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Prepare and invoke a build-in validator.\r\n   *\r\n   * @private\r\n   *\r\n   * @param {*} value Anything.\r\n   * @param {*} test The test case.\r\n   * @param {string} validatorType One of known to Sequelize validators.\r\n   * @param {string} field The field that is being validated\r\n   *\r\n   * @returns {object} An object with specific keys to invoke the validator.\r\n   */\r\n  async _invokeBuiltinValidator(value, test, validatorType, field) {\r\n    // Cast value as string to pass new Validator.js string requirement\r\n    const valueString = String(value);\r\n    // check if Validator knows that kind of validation test\r\n    if (typeof validator[validatorType] !== 'function') {\r\n      throw new TypeError(`Invalid validator function: ${validatorType}`);\r\n    }\r\n\r\n    const validatorArgs = this._extractValidatorArgs(test, validatorType, field);\r\n\r\n    if (!validator[validatorType](valueString, ...validatorArgs)) {\r\n      throw Object.assign(new Error(test.msg || `Validation ${validatorType} on ${field} failed`), { validatorName: validatorType, validatorArgs });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Will extract arguments for the validator.\r\n   *\r\n   * @param {*} test The test case.\r\n   * @param {string} validatorType One of known to Sequelize validators.\r\n   * @param {string} field The field that is being validated.\r\n   *\r\n   * @private\r\n   */\r\n  _extractValidatorArgs(test, validatorType, field) {\r\n    let validatorArgs = test.args || test;\r\n    const isLocalizedValidator = typeof validatorArgs !== 'string' && ['isAlpha', 'isAlphanumeric', 'isMobilePhone'].includes(validatorType);\r\n\r\n    if (!Array.isArray(validatorArgs)) {\r\n      if (validatorType === 'isImmutable') {\r\n        validatorArgs = [validatorArgs, field, this.modelInstance];\r\n      } else if (isLocalizedValidator || validatorType === 'isIP') {\r\n        validatorArgs = [];\r\n      } else {\r\n        validatorArgs = [validatorArgs];\r\n      }\r\n    } else {\r\n      validatorArgs = [...validatorArgs];\r\n    }\r\n\r\n    return validatorArgs;\r\n  }\r\n\r\n  /**\r\n   * Will validate a single field against its schema definition (isnull).\r\n   *\r\n   * @param {object} rawAttribute As defined in the Schema.\r\n   * @param {string} field The field name.\r\n   * @param {*} value anything.\r\n   *\r\n   * @private\r\n   */\r\n  _validateSchema(rawAttribute, field, value) {\r\n    if (rawAttribute.allowNull === false && (value === null || value === undefined)) {\r\n      const association = Object.values(this.modelInstance.constructor.associations).find(association => association instanceof BelongsTo && association.foreignKey === rawAttribute.fieldName);\r\n      if (!association || !this.modelInstance.get(association.as)) {\r\n        const validators = this.modelInstance.validators[field];\r\n        const errMsg = _.get(validators, 'notNull.msg', `${this.modelInstance.constructor.name}.${field} cannot be null`);\r\n\r\n        this.errors.push(new sequelizeError.ValidationErrorItem(\r\n          errMsg,\r\n          'notNull Violation', // sequelizeError.ValidationErrorItem.Origins.CORE,\r\n          field,\r\n          value,\r\n          this.modelInstance,\r\n          'is_null',\r\n        ));\r\n      }\r\n    }\r\n\r\n    if ((rawAttribute.type instanceof DataTypes.STRING || rawAttribute.type instanceof DataTypes.TEXT || rawAttribute.type instanceof DataTypes.CITEXT)\r\n      && (Array.isArray(value) || _.isObject(value) && !(value instanceof Utils.SequelizeMethod) && !Buffer.isBuffer(value))) {\r\n      this.errors.push(new sequelizeError.ValidationErrorItem(\r\n        `${field} cannot be an array or an object`,\r\n        'string violation', // sequelizeError.ValidationErrorItem.Origins.CORE,\r\n        field,\r\n        value,\r\n        this.modelInstance,\r\n        'not_a_string',\r\n      ));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Signs all errors retaining the original.\r\n   *\r\n   * @param {boolean}       isBuiltin   - Determines if error is from builtin validator.\r\n   * @param {string}        errorKey    - name of invalid attribute.\r\n   * @param {Error|string}  rawError    - The original error.\r\n   * @param {string|number} value       - The data that triggered the error.\r\n   * @param {string}        fnName      - Name of the validator, if any\r\n   * @param {Array}         fnArgs      - Arguments for the validator [function], if any\r\n   *\r\n   * @private\r\n   */\r\n  _pushError(isBuiltin, errorKey, rawError, value, fnName, fnArgs) {\r\n    const message = rawError.message || rawError || 'Validation error';\r\n    const error = new sequelizeError.ValidationErrorItem(\r\n      message,\r\n      'Validation error', // sequelizeError.ValidationErrorItem.Origins.FUNCTION,\r\n      errorKey,\r\n      value,\r\n      this.modelInstance,\r\n      fnName,\r\n      isBuiltin ? fnName : undefined,\r\n      isBuiltin ? fnArgs : undefined,\r\n    );\r\n\r\n    error[InstanceValidator.RAW_KEY_NAME] = rawError;\r\n\r\n    this.errors.push(error);\r\n  }\r\n}\r\n\r\n/**\r\n * The error key for arguments as passed by custom validators\r\n *\r\n * @type {string}\r\n * @private\r\n */\r\nInstanceValidator.RAW_KEY_NAME = 'original';\r\n"],
  "mappings": "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",
  "names": []
}
