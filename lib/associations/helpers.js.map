{
  "version": 3,
  "sources": ["../../src/associations/helpers.ts"],
  "sourcesContent": ["import assert from 'assert';\r\nimport NodeUtils from 'util';\r\nimport isEqual from 'lodash/isEqual';\r\nimport isPlainObject from 'lodash/isPlainObject.js';\r\nimport isUndefined from 'lodash/isUndefined';\r\nimport lowerFirst from 'lodash/lowerFirst';\r\nimport omit from 'lodash/omit';\r\nimport omitBy from 'lodash/omitBy';\r\nimport type { Class } from 'type-fest';\r\nimport { AssociationError } from '../errors/index.js';\r\nimport type { Model, ModelAttributeColumnOptions, ModelStatic } from '../model';\r\nimport type { Sequelize } from '../sequelize';\r\nimport * as deprecations from '../utils/deprecations.js';\r\nimport * as Utils from '../utils/index.js';\r\nimport type { OmitConstructors } from '../utils/index.js';\r\nimport { isModelStatic, isSameInitialModel } from '../utils/model-utils.js';\r\nimport type { Association, AssociationOptions, NormalizedAssociationOptions, ForeignKeyOptions } from './base';\r\n\r\nexport function checkNamingCollision(source: ModelStatic<any>, associationName: string): void {\r\n  if (Object.prototype.hasOwnProperty.call(source.getAttributes(), associationName)) {\r\n    throw new Error(\r\n      `Naming collision between attribute '${associationName}'`\r\n      + ` and association '${associationName}' on model ${source.name}`\r\n      + '. To remedy this, change the \"as\" options in your association definition',\r\n    );\r\n  }\r\n}\r\n\r\nexport function addForeignKeyConstraints(\r\n  newAttribute: ModelAttributeColumnOptions,\r\n  source: ModelStatic<Model>,\r\n  options: AssociationOptions<string>,\r\n  key: string,\r\n): void {\r\n  // FK constraints are opt-in: users must either set `foreignKeyConstraints`\r\n  // on the association, or request an `onDelete` or `onUpdate` behavior\r\n\r\n  if (options.foreignKeyConstraints !== false) {\r\n    // Find primary keys: composite keys not supported with this approach\r\n    const primaryKeys = Object.keys(source.primaryKeys)\r\n      .map(primaryKeyAttribute => source.getAttributes()[primaryKeyAttribute].field || primaryKeyAttribute);\r\n\r\n    if (primaryKeys.length === 1 || !primaryKeys.includes(key)) {\r\n      newAttribute.references = {\r\n        model: source.getTableName(),\r\n        key: key || primaryKeys[0],\r\n      };\r\n\r\n      newAttribute.onDelete = newAttribute.onDelete ?? (newAttribute.allowNull !== false ? 'SET NULL' : 'CASCADE');\r\n      newAttribute.onUpdate = newAttribute.onUpdate ?? 'CASCADE';\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Mixin (inject) association methods to model prototype\r\n *\r\n * @private\r\n *\r\n * @param association instance\r\n * @param mixinTargetPrototype Model prototype\r\n * @param methods Method names to inject\r\n * @param aliases Mapping between model and association method names\r\n *\r\n */\r\nexport function mixinMethods<A extends Association, Aliases extends Record<string, string>>(\r\n  association: A,\r\n  mixinTargetPrototype: Model,\r\n  methods: Array<keyof A | keyof Aliases>,\r\n  aliases?: Aliases,\r\n): void {\r\n  for (const method of methods) {\r\n    // @ts-expect-error\r\n    const targetMethodName = association.accessors[method];\r\n\r\n    // don't override custom methods\r\n    if (Object.prototype.hasOwnProperty.call(mixinTargetPrototype, targetMethodName)) {\r\n      continue;\r\n    }\r\n\r\n    // @ts-expect-error\r\n    const realMethod = aliases?.[method] || method;\r\n\r\n    Object.defineProperty(mixinTargetPrototype, targetMethodName, {\r\n      enumerable: false,\r\n      value(...params: any[]) {\r\n        // @ts-expect-error\r\n        return association[realMethod](this, ...params);\r\n      },\r\n    });\r\n  }\r\n}\r\n\r\n/**\r\n * Used to prevent users from instantiating Associations themselves.\r\n * Instantiating associations is not safe as it mutates the Model object.\r\n *\r\n * @internal\r\n * @private do not expose outside sequelize\r\n */\r\nexport const AssociationConstructorSecret = Symbol('AssociationConstructorPrivateKey');\r\n\r\nexport function getModel<M extends Model>(\r\n  sequelize: Sequelize,\r\n  model: string | ModelStatic<M>,\r\n): ModelStatic<M> | null {\r\n  if (typeof model === 'string') {\r\n    if (!sequelize.isDefined(model)) {\r\n      return null;\r\n    }\r\n\r\n    return sequelize.model(model) as ModelStatic<M>;\r\n  }\r\n\r\n  return model;\r\n}\r\n\r\nexport function removeUndefined<T>(val: T): T {\r\n  return omitBy(val, isUndefined) as T;\r\n}\r\n\r\nexport function assertAssociationUnique(\r\n  type: Class<Association>,\r\n  source: ModelStatic<any>,\r\n  target: ModelStatic<any>,\r\n  options: NormalizedAssociationOptions<any>,\r\n  parent: Association | undefined,\r\n) {\r\n  const as = options.as;\r\n\r\n  const existingAssociation = source.associations[as];\r\n  if (!existingAssociation) {\r\n    return;\r\n  }\r\n\r\n  const incompatibilityStatus = getAssociationsIncompatibilityStatus(existingAssociation, type, target, options);\r\n  if ((parent || existingAssociation.parentAssociation) && incompatibilityStatus == null) {\r\n    return;\r\n  }\r\n\r\n  const existingRoot = existingAssociation.rootAssociation;\r\n\r\n  if (!parent && existingRoot === existingAssociation) {\r\n    throw new AssociationError(`You have defined two associations with the same name \"${as}\" on the model \"${source.name}\". Use another alias using the \"as\" parameter.`);\r\n  }\r\n\r\n  throw new AssociationError(`\r\n${parent ? `The association \"${parent.as}\" needs to define` : `You are trying to define`} the ${type.name} association \"${options.as}\" from ${source.name} to ${target.name},\r\nbut that child association has already been defined as ${existingAssociation.associationType}, to ${target.name} by this call:\r\n\r\n${existingRoot.source.name}.${lowerFirst(existingRoot.associationType)}(${existingRoot.target.name}, ${NodeUtils.inspect(existingRoot.options)})\r\n\r\nThat association would be re-used if compatible, but it is incompatible because ${\r\n  incompatibilityStatus === IncompatibilityStatus.DIFFERENT_TYPES ? `their types are different (${type.name} vs ${existingAssociation.associationType})`\r\n    : incompatibilityStatus === IncompatibilityStatus.DIFFERENT_TARGETS ? `they target different models (${target.name} vs ${existingAssociation.target.name})`\r\n    : `their options are not reconcilable:\r\n\r\nOptions of the association to create:\r\n${NodeUtils.inspect(omit(options, 'inverse'), { sorted: true })}\r\n\r\nOptions of the existing association:\r\n${NodeUtils.inspect(omit(existingAssociation.options as any, 'inverse'), { sorted: true })}\r\n`}`.trim());\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nenum IncompatibilityStatus {\r\n  DIFFERENT_TYPES = 0,\r\n  DIFFERENT_TARGETS = 1,\r\n  DIFFERENT_OPTIONS = 2,\r\n}\r\n\r\nfunction getAssociationsIncompatibilityStatus(\r\n  existingAssociation: Association,\r\n  newAssociationType: Class<Association>,\r\n  newTarget: ModelStatic<Model>,\r\n  newOptions: NormalizeBaseAssociationOptions<any>,\r\n): IncompatibilityStatus | null {\r\n  if (existingAssociation.associationType !== newAssociationType.name) {\r\n    return IncompatibilityStatus.DIFFERENT_TYPES;\r\n  }\r\n\r\n  if (!isSameInitialModel(existingAssociation.target, newTarget)) {\r\n    return IncompatibilityStatus.DIFFERENT_TARGETS;\r\n  }\r\n\r\n  const opts1 = omit(existingAssociation.options as any, 'inverse');\r\n  const opts2 = omit(newOptions, 'inverse');\r\n  if (!isEqual(opts1, opts2)) {\r\n    return IncompatibilityStatus.DIFFERENT_OPTIONS;\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\nexport function assertAssociationModelIsDefined(model: ModelStatic<any>): void {\r\n  if (!model.sequelize) {\r\n    throw new Error(`Model ${model.name} must be defined (through Model.init or Sequelize#define) before calling one of its association declaration methods.`);\r\n  }\r\n}\r\n\r\nexport type AssociationStatic<T extends Association> = Class<T> & OmitConstructors<typeof Association>;\r\n\r\nexport function defineAssociation<\r\n  T extends Association,\r\n  RawOptions extends AssociationOptions<any>,\r\n  CleanOptions extends NormalizedAssociationOptions<any>,\r\n>(\r\n  type: AssociationStatic<T>,\r\n  source: ModelStatic<Model>,\r\n  target: ModelStatic<Model>,\r\n  options: RawOptions,\r\n  parent: Association<any> | undefined,\r\n  normalizeOptions: (\r\n    type: AssociationStatic<T>,\r\n    options: RawOptions,\r\n    source: ModelStatic<Model>,\r\n    target: ModelStatic<Model>\r\n  ) => CleanOptions,\r\n  construct: (opts: CleanOptions) => T,\r\n): T {\r\n  if (!isModelStatic(target)) {\r\n    throw new Error(`${source.name}.${lowerFirst(type.name)} called with something that's not a subclass of Sequelize.Model`);\r\n  }\r\n\r\n  assertAssociationModelIsDefined(source);\r\n  assertAssociationModelIsDefined(target);\r\n\r\n  const normalizedOptions = normalizeOptions(type, options, source, target);\r\n\r\n  checkNamingCollision(source, normalizedOptions.as);\r\n  assertAssociationUnique(type, source, target, normalizedOptions, parent);\r\n\r\n  const sequelize = source.sequelize!;\r\n  Object.defineProperty(normalizedOptions, 'sequelize', {\r\n    configurable: true,\r\n    get() {\r\n      deprecations.movedSequelizeParam();\r\n\r\n      return sequelize;\r\n    },\r\n  });\r\n\r\n  if (normalizedOptions.hooks) {\r\n    source.runHooks('beforeAssociate', { source, target, type, sequelize }, normalizedOptions);\r\n  }\r\n\r\n  let association;\r\n  try {\r\n    association = source.associations[normalizedOptions.as] as T ?? construct(normalizedOptions);\r\n  } catch (error) {\r\n    throw new AssociationError(\r\n      parent\r\n        ? `Association \"${parent.as}\" needs to create the ${type.name} association \"${normalizedOptions.as}\" from ${source.name} to ${target.name}, but it failed`\r\n        : `Defining ${type.name} association \"${normalizedOptions.as}\" from ${source.name} to ${target.name} failed`,\r\n      { cause: error as Error },\r\n    );\r\n  }\r\n\r\n  if (normalizedOptions.hooks) {\r\n    source.runHooks('afterAssociate', { source, target, type, association, sequelize }, normalizedOptions);\r\n  }\r\n\r\n  checkNamingCollision(source, normalizedOptions.as);\r\n\r\n  return association;\r\n}\r\n\r\nexport type NormalizeBaseAssociationOptions<T> = Omit<T, 'as' | 'hooks' | 'foreignKey'> & {\r\n  as: string,\r\n  name: { singular: string, plural: string },\r\n  hooks: boolean,\r\n  foreignKey: ForeignKeyOptions<any>,\r\n};\r\n\r\nexport function normalizeBaseAssociationOptions<T extends AssociationOptions<any>>(\r\n  associationType: AssociationStatic<any>,\r\n  options: T,\r\n  source: ModelStatic<Model>,\r\n  target: ModelStatic<Model>,\r\n): NormalizeBaseAssociationOptions<T> {\r\n\r\n  if ('onDelete' in options || 'onUpdate' in options) {\r\n    throw new Error('Options \"onDelete\" and \"onUpdate\" have been moved to \"foreignKey.onDelete\" and \"foreignKey.onUpdate\" (also available as \"otherKey\" in belongsToMany)');\r\n  }\r\n\r\n  if ('constraints' in options) {\r\n    throw new Error('Option \"constraints\" has been renamed to \"foreignKeyConstraints\"');\r\n  }\r\n\r\n  if ('foreignKeyConstraint' in options) {\r\n    throw new Error('Option \"foreignKeyConstraint\" has been renamed to \"foreignKeyConstraints\" (with a \"s\" at the end)');\r\n  }\r\n\r\n  const isMultiAssociation = associationType.isMultiAssociation;\r\n\r\n  let name: { singular: string, plural: string };\r\n  let as: string;\r\n  if (options?.as) {\r\n    if (isPlainObject(options.as)) {\r\n      assert(typeof options.as === 'object');\r\n      name = options.as;\r\n      as = isMultiAssociation ? options.as.plural : options.as.singular;\r\n    } else {\r\n      assert(typeof options.as === 'string');\r\n      as = options.as;\r\n      name = {\r\n        plural: isMultiAssociation ? options.as : Utils.pluralize(options.as),\r\n        singular: isMultiAssociation ? Utils.singularize(options.as) : options.as,\r\n      };\r\n    }\r\n  } else {\r\n    as = isMultiAssociation ? target.options.name.plural : target.options.name.singular;\r\n    name = target.options.name;\r\n  }\r\n\r\n  return removeUndefined({\r\n    ...options,\r\n    foreignKey: normalizeForeignKeyOptions(options.foreignKey),\r\n    hooks: options.hooks ?? false,\r\n    as,\r\n    name,\r\n  });\r\n}\r\n\r\nexport function normalizeForeignKeyOptions<T extends string>(foreignKey: AssociationOptions<T>['foreignKey']): ForeignKeyOptions<any> {\r\n  return typeof foreignKey === 'string' ? { name: foreignKey } : removeUndefined({\r\n    ...foreignKey,\r\n    name: foreignKey?.name ?? foreignKey?.fieldName,\r\n    fieldName: undefined,\r\n  });\r\n}\r\n"],
  "mappings": "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",
  "names": []
}
