{
  "version": 3,
  "sources": ["../../src/associations/belongs-to.ts"],
  "sourcesContent": ["import assert from 'assert';\r\nimport isObject from 'lodash/isObject.js';\r\nimport upperFirst from 'lodash/upperFirst';\r\nimport { AssociationError } from '../errors/index.js';\r\nimport type {\r\n  ModelStatic,\r\n  Model,\r\n  CreateOptions,\r\n  CreationAttributes,\r\n  FindOptions,\r\n  SaveOptions,\r\n  AttributeNames,\r\n  Attributes,\r\n} from '../model';\r\nimport { Op } from '../operators';\r\nimport * as Utils from '../utils';\r\nimport { isSameInitialModel } from '../utils/model-utils.js';\r\nimport type { AssociationOptions, SingleAssociationAccessors } from './base';\r\nimport { Association } from './base';\r\nimport { HasMany } from './has-many.js';\r\nimport { HasOne } from './has-one.js';\r\nimport type { NormalizeBaseAssociationOptions } from './helpers';\r\nimport {\r\n  addForeignKeyConstraints,\r\n  defineAssociation,\r\n  mixinMethods, normalizeBaseAssociationOptions,\r\n} from './helpers';\r\n\r\n/**\r\n * One-to-one association\r\n * See {@link Model.belongsTo}\r\n *\r\n * This is almost the same as {@link HasOne}, but the foreign key will be defined on the source model.\r\n *\r\n * In the API reference below, add the name of the association to the method, e.g. for `User.belongsTo(Project)` the getter will be `user.getProject()`.\r\n *\r\n * @typeParam S The model on which {@link Model.belongsTo} has been called, on which the association methods, as well as the foreign key attribute, will be added.\r\n * @typeParam T The model passed to {@link Model.belongsTo}.\r\n * @typeParam SourceKey The name of the Foreign Key attribute on the Source model.\r\n * @typeParam TargetKey The name of the attribute that the foreign key in the source model will reference, typically the Primary Key.\r\n */\r\nexport class BelongsTo<\r\n  S extends Model = Model,\r\n  T extends Model = Model,\r\n  SourceKey extends AttributeNames<S> = any,\r\n  TargetKey extends AttributeNames<T> = any,\r\n> extends Association<S, T, SourceKey, NormalizedBelongsToOptions<SourceKey, TargetKey>> {\r\n\r\n  readonly accessors: SingleAssociationAccessors;\r\n\r\n  /**\r\n   * The attribute name of the identifier\r\n   *\r\n   * @deprecated use {@link foreignKey} instead\r\n   */\r\n  get identifier(): string {\r\n    return this.foreignKey;\r\n  }\r\n\r\n  foreignKey: SourceKey;\r\n\r\n  /**\r\n   * The column name of the foreign key\r\n   */\r\n  identifierField: string;\r\n\r\n  /**\r\n   * The name of the attribute the foreign key points to.\r\n   * In belongsTo, this key is on the Target Model, instead of the Source Model  (unlike {@link HasOne.sourceKey}).\r\n   * The {@link Association.foreignKey} is on the Source Model.\r\n   */\r\n  targetKey: TargetKey;\r\n\r\n  /**\r\n   * The column name of the target key\r\n   */\r\n  readonly targetKeyField: string;\r\n\r\n  readonly targetKeyIsPrimary: boolean;\r\n\r\n  /**\r\n   * @deprecated use {@link BelongsTo.targetKey}\r\n   */\r\n  get targetIdentifier(): string {\r\n    return this.targetKey;\r\n  }\r\n\r\n  inverse: Association | undefined;\r\n\r\n  constructor(\r\n    secret: symbol,\r\n    source: ModelStatic<S>,\r\n    target: ModelStatic<T>,\r\n    options: NormalizedBelongsToOptions<SourceKey, TargetKey>,\r\n    parent?: Association,\r\n  ) {\r\n    // TODO: throw is source model has a composite primary key.\r\n    const targetKey = options?.targetKey || (target.primaryKeyAttribute as TargetKey);\r\n\r\n    if (!target.getAttributes()[targetKey]) {\r\n      throw new Error(`Unknown attribute \"${options.targetKey}\" passed as targetKey, define this attribute on model \"${target.name}\" first`);\r\n    }\r\n\r\n    if ('keyType' in options) {\r\n      throw new TypeError('Option \"keyType\" has been removed from the BelongsTo\\'s options. Set \"foreignKey.type\" instead.');\r\n    }\r\n\r\n    super(secret, source, target, options, parent);\r\n\r\n    this.targetKey = targetKey;\r\n\r\n    // For Db2 server, a reference column of a FOREIGN KEY must be unique\r\n    // else, server throws SQL0573N error. Hence, setting it here explicitly\r\n    // for non primary columns.\r\n    if (target.sequelize!.options.dialect === 'db2' && this.target.getAttributes()[this.targetKey].primaryKey !== true) {\r\n      // TODO: throw instead\r\n      this.target.getAttributes()[this.targetKey].unique = true;\r\n    }\r\n\r\n    let foreignKey: string | undefined;\r\n    let foreignKeyAttributeOptions;\r\n    if (isObject(this.options?.foreignKey)) {\r\n      // lodash has poor typings\r\n      assert(typeof this.options?.foreignKey === 'object');\r\n\r\n      foreignKeyAttributeOptions = this.options.foreignKey;\r\n      foreignKey = this.options.foreignKey.name || this.options.foreignKey.fieldName;\r\n    } else if (this.options?.foreignKey) {\r\n      foreignKey = this.options.foreignKey;\r\n    }\r\n\r\n    if (!foreignKey) {\r\n      foreignKey = this.inferForeignKey();\r\n    }\r\n\r\n    this.foreignKey = foreignKey as SourceKey;\r\n\r\n    const newForeignKeyAttribute = {\r\n      type: this.target.rawAttributes[this.targetKey].type,\r\n      ...foreignKeyAttributeOptions,\r\n      allowNull: this.source.rawAttributes[this.foreignKey]?.allowNull ?? foreignKeyAttributeOptions?.allowNull,\r\n    };\r\n\r\n    this.targetKeyField = Utils.getColumnName(this.target.getAttributes()[this.targetKey]);\r\n    this.targetKeyIsPrimary = this.targetKey === this.target.primaryKeyAttribute;\r\n\r\n    addForeignKeyConstraints(newForeignKeyAttribute, this.target, this.options, this.targetKeyField);\r\n\r\n    this.source.mergeAttributesDefault({\r\n      [this.foreignKey]: newForeignKeyAttribute,\r\n    });\r\n\r\n    this.identifierField = Utils.getColumnName(this.source.getAttributes()[this.foreignKey]);\r\n\r\n    // Get singular name, trying to uppercase the first letter, unless the model forbids it\r\n    const singular = upperFirst(this.options.name.singular);\r\n\r\n    this.accessors = {\r\n      get: `get${singular}`,\r\n      set: `set${singular}`,\r\n      create: `create${singular}`,\r\n    };\r\n\r\n    this.#mixin(source.prototype);\r\n\r\n    if (options.inverse) {\r\n      const passDown = {\r\n        ...options,\r\n        as: options.inverse.as,\r\n        scope: options.inverse?.scope,\r\n        sourceKey: options.targetKey,\r\n        inverse: undefined,\r\n      };\r\n\r\n      delete passDown.targetKey;\r\n\r\n      switch (options.inverse.type) {\r\n        case 'hasMany':\r\n          HasMany.associate(secret, target, source, passDown, this);\r\n          break;\r\n\r\n        case 'hasOne':\r\n          HasOne.associate(secret, target, source, passDown, this);\r\n          break;\r\n\r\n        default:\r\n          throw new Error(`Invalid option received for \"inverse.type\": ${options.inverse.type} is not recognised. Expected \"hasMany\" or \"hasOne\"`);\r\n      }\r\n    }\r\n  }\r\n\r\n  static associate<\r\n    S extends Model,\r\n    T extends Model,\r\n    SourceKey extends AttributeNames<S>,\r\n    TargetKey extends AttributeNames<T>,\r\n    >(\r\n    secret: symbol,\r\n    source: ModelStatic<S>,\r\n    target: ModelStatic<T>,\r\n    options: BelongsToOptions<SourceKey, TargetKey> = {},\r\n    parent?: Association<any>,\r\n  ): BelongsTo<S, T, SourceKey, TargetKey> {\r\n    return defineAssociation<\r\n      BelongsTo<S, T, SourceKey, TargetKey>,\r\n      BelongsToOptions<SourceKey, TargetKey>,\r\n      NormalizedBelongsToOptions<SourceKey, TargetKey>\r\n    >(BelongsTo, source, target, options, parent, normalizeBaseAssociationOptions, normalizedOptions => {\r\n      // self-associations must always set their 'as' parameter\r\n      if (isSameInitialModel(source, target) && options.inverse\r\n        // use 'options' because this will always be set in 'newOptions'\r\n        && (!options.as || !options.inverse.as || options.as === options.inverse.as)) {\r\n        throw new AssociationError(`Both options \"as\" and \"inverse.as\" must be defined for belongsTo self-associations, and their value must be different, if you specify the 'inverse' option.`);\r\n      }\r\n\r\n      return new BelongsTo(secret, source, target, normalizedOptions, parent);\r\n    });\r\n  }\r\n\r\n  #mixin(modelPrototype: Model): void {\r\n    mixinMethods(this, modelPrototype, ['get', 'set', 'create']);\r\n  }\r\n\r\n  protected inferForeignKey(): string {\r\n    const associationName = Utils.singularize(this.options.as);\r\n    if (!associationName) {\r\n      throw new Error('Sanity check: Could not guess the name of the association');\r\n    }\r\n\r\n    return Utils.camelize(`${associationName}_${this.targetKey}`);\r\n  }\r\n\r\n  /**\r\n   * Get the associated instance.\r\n   *\r\n   * See {@link BelongsToGetAssociationMixinOptions} for a full explanation of options.\r\n   * This method is mixed-in the source model prototype. See {@link BelongsToGetAssociationMixin}.\r\n   *\r\n   * @param instances source instances\r\n   * @param options find options\r\n   */\r\n  async get(instances: S, options: BelongsToGetAssociationMixinOptions<T>): Promise<T | null>;\r\n  async get(instances: S[], options: BelongsToGetAssociationMixinOptions<T>): Promise<Map<any, T | null>>;\r\n  async get(\r\n    instances: S | S[],\r\n    options: BelongsToGetAssociationMixinOptions<T>,\r\n  ): Promise<Map<any, T | null> | T | null> {\r\n    options = Utils.cloneDeep(options);\r\n\r\n    let Target = this.target;\r\n    if (options.scope != null) {\r\n      if (!options.scope) {\r\n        Target = Target.unscoped();\r\n      } else if (options.scope !== true) { // 'true' means default scope. Which is the same as not doing anything.\r\n        Target = Target.scope(options.scope);\r\n      }\r\n    }\r\n\r\n    if (options.schema != null) {\r\n      Target = Target.schema(options.schema, options.schemaDelimiter);\r\n    }\r\n\r\n    let isManyMode = true;\r\n    if (!Array.isArray(instances)) {\r\n      isManyMode = false;\r\n      instances = [instances];\r\n    }\r\n\r\n    // TODO: the scope is ignored\r\n    const where = Object.create(null);\r\n\r\n    if (instances.length > 1) {\r\n      where[this.targetKey] = {\r\n        [Op.in]: instances.map(_instance => _instance.get(this.foreignKey)),\r\n      };\r\n    } else {\r\n      const foreignKeyValue = instances[0].get(this.foreignKey);\r\n\r\n      if (this.targetKeyIsPrimary && !options.where) {\r\n        return Target.findByPk(\r\n          foreignKeyValue as any,\r\n          options,\r\n        );\r\n      }\r\n\r\n      where[this.targetKey] = foreignKeyValue;\r\n      options.limit = null;\r\n    }\r\n\r\n    options.where = options.where\r\n      ? { [Op.and]: [where, options.where] }\r\n      : where;\r\n\r\n    if (isManyMode) {\r\n      const results = await Target.findAll(options);\r\n      const result: Map<any, T | null> = new Map();\r\n\r\n      for (const instance of results) {\r\n        result.set(instance.get(this.targetKey, { raw: true }), instance);\r\n      }\r\n\r\n      return result;\r\n    }\r\n\r\n    return Target.findOne(options);\r\n  }\r\n\r\n  /**\r\n   * Set the associated model.\r\n   *\r\n   * @param sourceInstance the source instance\r\n   * @param associatedInstance An persisted instance or the primary key of an instance to associate with this. Pass `null` to remove the association.\r\n   * @param options options passed to `this.save`\r\n   */\r\n  async set(\r\n    sourceInstance: S,\r\n    associatedInstance: T | T[TargetKey] | null,\r\n    options: BelongsToSetAssociationMixinOptions<T> = {},\r\n  ): Promise<void> {\r\n    let value = associatedInstance;\r\n\r\n    if (associatedInstance != null && associatedInstance instanceof this.target) {\r\n      value = (associatedInstance as T)[this.targetKey];\r\n    }\r\n\r\n    sourceInstance.set(this.foreignKey, value);\r\n\r\n    if (options.save === false) {\r\n      return;\r\n    }\r\n\r\n    // passes the changed field to save, so only that field get updated.\r\n    await sourceInstance.save({\r\n      fields: [this.foreignKey],\r\n      association: true,\r\n      ...options,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Create a new instance of the associated model and associate it with this.\r\n   *\r\n   * @param sourceInstance the source instance\r\n   * @param values values to create associated model instance with\r\n   * @param options Options passed to `target.create` and setAssociation.\r\n   *\r\n   * @returns The created target model\r\n   */\r\n  async create(\r\n    sourceInstance: S,\r\n    // @ts-expect-error -- {} is not always assignable to 'values', but Target.create will enforce this, not us.\r\n    values: CreationAttributes<T> = {},\r\n    options: BelongsToCreateAssociationMixinOptions<T> = {},\r\n  ): Promise<T> {\r\n    values = values || {};\r\n    options = options || {};\r\n\r\n    const newAssociatedObject = await this.target.create(values, options);\r\n    await this.set(sourceInstance, newAssociatedObject, options);\r\n\r\n    return newAssociatedObject;\r\n  }\r\n}\r\n\r\n// workaround https://github.com/evanw/esbuild/issues/1260\r\nObject.defineProperty(BelongsTo, 'name', {\r\n  value: 'BelongsTo',\r\n});\r\n\r\nexport type NormalizedBelongsToOptions<SourceKey extends string, TargetKey extends string> =\r\n  NormalizeBaseAssociationOptions<BelongsToOptions<SourceKey, TargetKey>>;\r\n\r\n/**\r\n * Options provided when associating models with belongsTo relationship\r\n *\r\n * @see Association class belongsTo method\r\n */\r\nexport interface BelongsToOptions<SourceKey extends string, TargetKey extends string> extends AssociationOptions<SourceKey> {\r\n  /**\r\n   * The name of the field to use as the key for the association in the target table. Defaults to the primary\r\n   * key of the target table\r\n   */\r\n  targetKey?: TargetKey;\r\n\r\n  inverse?: {\r\n    type: 'hasMany' | 'hasOne',\r\n    as?: string,\r\n    scope?: AssociationOptions<any>['scope'],\r\n  };\r\n}\r\n\r\n/**\r\n * The options for the getAssociation mixin of the belongsTo association.\r\n *\r\n * @see BelongsToGetAssociationMixin\r\n */\r\nexport interface BelongsToGetAssociationMixinOptions<T extends Model> extends FindOptions<Attributes<T>> {\r\n  /**\r\n   * Apply a scope on the related model, or remove its default scope by passing false.\r\n   */\r\n  scope?: string | string[] | boolean;\r\n\r\n  /**\r\n   * Apply a schema on the related model\r\n   */\r\n  schema?: string;\r\n  schemaDelimiter?: string;\r\n}\r\n\r\n/**\r\n * The getAssociation mixin applied to models with belongsTo.\r\n * An example of usage is as follows:\r\n *\r\n * ```typescript\r\n * class User extends Model<InferAttributes<User>, InferCreationAttributes<User>> {\r\n *  declare getRole: BelongsToGetAssociationMixin<Role>;\r\n * }\r\n *\r\n * User.belongsTo(Role);\r\n * ```\r\n *\r\n * @see Model.belongsTo\r\n */\r\n// TODO: in the future, type the return value based on whether the foreign key is nullable or not on the source model.\r\n//   if nullable, return TModel | null\r\n//   https://github.com/sequelize/meetings/issues/14\r\nexport type BelongsToGetAssociationMixin<T extends Model> =\r\n  (options?: BelongsToGetAssociationMixinOptions<T>) => Promise<T | null>;\r\n\r\n/**\r\n * The options for the setAssociation mixin of the belongsTo association.\r\n *\r\n * @see BelongsToSetAssociationMixin\r\n */\r\nexport interface BelongsToSetAssociationMixinOptions<T extends Model> extends SaveOptions<Attributes<T>> {\r\n  /**\r\n   * Skip saving this after setting the foreign key if false.\r\n   */\r\n  save?: boolean;\r\n}\r\n\r\n/**\r\n * The setAssociation mixin applied to models with belongsTo.\r\n * An example of usage is as follows:\r\n *\r\n * ```typescript\r\n * class User extends Model<InferAttributes<User>, InferCreationAttributes<User>> {\r\n *  declare setRole: BelongsToSetAssociationMixin<Role, Role['id']>;\r\n * }\r\n *\r\n * User.belongsTo(Role);\r\n * ```\r\n *\r\n * @see Model.belongsTo\r\n *\r\n * @typeParam TargetKeyType The type of the attribute that the foreign key references.\r\n */\r\nexport type BelongsToSetAssociationMixin<T extends Model, TargetKeyType> = (\r\n  newAssociation?: T | TargetKeyType,\r\n  options?: BelongsToSetAssociationMixinOptions<T>\r\n) => Promise<void>;\r\n\r\n/**\r\n * The options for the createAssociation mixin of the belongsTo association.\r\n *\r\n * @see BelongsToCreateAssociationMixin\r\n */\r\nexport interface BelongsToCreateAssociationMixinOptions<T extends Model>\r\n  extends CreateOptions<Attributes<T>>, BelongsToSetAssociationMixinOptions<T> {}\r\n\r\n/**\r\n * The createAssociation mixin applied to models with belongsTo.\r\n * An example of usage is as follows:\r\n *\r\n * ```typescript\r\n * class User extends Model<InferAttributes<User>, InferCreationAttributes<User>> {\r\n *   declare createRole: BelongsToCreateAssociationMixin<Role>;\r\n * }\r\n *\r\n * User.belongsTo(Role);\r\n * ```\r\n *\r\n * @see Model.belongsTo\r\n */\r\nexport type BelongsToCreateAssociationMixin<T extends Model> = (\r\n  values?: CreationAttributes<T>,\r\n  options?: BelongsToCreateAssociationMixinOptions<T>\r\n) => Promise<T>;\r\n"],
  "mappings": "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",
  "names": []
}
