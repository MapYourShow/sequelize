{
  "version": 3,
  "sources": ["../../../src/dialects/ibmi/query-generator.js"],
  "sourcesContent": ["'use strict';\r\n\r\nimport { removeTrailingSemicolon } from '../../utils';\r\n\r\nconst Utils = require('../../utils');\r\nconst util = require('util');\r\nconst _ = require('lodash');\r\nconst { AbstractQueryGenerator } = require('../abstract/query-generator');\r\nconst DataTypes = require('../../data-types');\r\nconst { Model } = require('../../model');\r\nconst SqlString = require('../../sql-string');\r\n\r\nconst typeWithoutDefault = new Set(['BLOB']);\r\n\r\nexport class IBMiQueryGenerator extends AbstractQueryGenerator {\r\n\r\n  // Version queries\r\n  versionQuery() {\r\n    return 'SELECT CONCAT(OS_VERSION, CONCAT(\\'.\\', OS_RELEASE)) AS VERSION FROM SYSIBMADM.ENV_SYS_INFO';\r\n  }\r\n\r\n  // Schema queries\r\n  createSchema(schema) {\r\n    return `CREATE SCHEMA \"${schema}\"`;\r\n  }\r\n\r\n  dropSchema(schema) {\r\n    return `BEGIN IF EXISTS (SELECT * FROM SYSIBM.SQLSCHEMAS WHERE TABLE_SCHEM = ${schema ? `'${schema}'` : 'CURRENT SCHEMA'}) THEN SET TRANSACTION ISOLATION LEVEL NO COMMIT; DROP SCHEMA \"${schema ? `${schema}` : 'CURRENT SCHEMA'}\"; COMMIT; END IF; END`;\r\n  }\r\n\r\n  showSchemasQuery(options) {\r\n    let skippedSchemas = '';\r\n    if (options.skip) {\r\n      for (let i = 0; i < options.skip.length; i++) {\r\n        skippedSchemas += ` AND SCHEMA_NAME != '${options.skip[i]}'`;\r\n      }\r\n    }\r\n\r\n    return `SELECT DISTINCT SCHEMA_NAME AS \"schema_name\" FROM QSYS2.SYSSCHEMAAUTH WHERE GRANTEE = CURRENT USER${skippedSchemas}`;\r\n  }\r\n\r\n  // Table queries\r\n  createTableQuery(tableName, attributes, options) {\r\n    const primaryKeys = [];\r\n    const foreignKeys = Object.create(null);\r\n    const attrStr = [];\r\n\r\n    for (const attr in attributes) {\r\n      if (!Object.prototype.hasOwnProperty.call(attributes, attr)) {\r\n        continue;\r\n      }\r\n\r\n      const dataType = attributes[attr];\r\n\r\n      if (dataType.includes('PRIMARY KEY')) {\r\n        primaryKeys.push(attr);\r\n        attrStr.push(`${this.quoteIdentifier(attr)} ${dataType.replace('PRIMARY KEY', '')}`);\r\n      } else {\r\n        attrStr.push(`${this.quoteIdentifier(attr)} ${dataType}`);\r\n      }\r\n    }\r\n\r\n    let attributesClause = attrStr.join(', ');\r\n    const pkString = primaryKeys.map(pk => this.quoteIdentifier(pk)).join(', ');\r\n\r\n    if (options.uniqueKeys) {\r\n      // only need to sort primary keys once, don't do it in place\r\n      const sortedPrimaryKeys = [...primaryKeys];\r\n      sortedPrimaryKeys.sort();\r\n\r\n      _.each(options.uniqueKeys, (columns, indexName) => {\r\n        // sort the columns for each unique key, so they can be easily compared\r\n        // with the sorted primary key fields\r\n        const sortedColumnFields = [...columns.fields];\r\n        sortedColumnFields.sort();\r\n        // if primary keys === unique keys, then skip adding new constraint\r\n        const uniqueIsPrimary\r\n          = sortedColumnFields.length === primaryKeys.length\r\n          && sortedColumnFields.every((value, index) => {\r\n            return value === sortedPrimaryKeys[index];\r\n          });\r\n        if (uniqueIsPrimary) {\r\n          return true;\r\n        }\r\n\r\n        if (columns.customIndex) {\r\n          if (typeof indexName !== 'string') {\r\n            indexName = `uniq_${tableName}_${columns.fields.join('_')}`;\r\n          }\r\n\r\n          attributesClause += `, CONSTRAINT ${this.quoteIdentifier(indexName)} UNIQUE (${columns.fields.map(field => this.quoteIdentifier(field)).join(', ')})`;\r\n        }\r\n      });\r\n    }\r\n\r\n    if (pkString.length > 0) {\r\n      attributesClause += `, PRIMARY KEY (${pkString})`;\r\n    }\r\n\r\n    for (const fkey in foreignKeys) {\r\n      if (Object.prototype.hasOwnProperty.call(foreignKeys, fkey)) {\r\n        attributesClause += `, FOREIGN KEY (${this.quoteIdentifier(fkey)}) ${foreignKeys[fkey]}`;\r\n      }\r\n    }\r\n\r\n    let tableObject;\r\n    if (typeof tableName === 'string') {\r\n      tableObject = { table: tableName };\r\n    } else {\r\n      tableObject = tableName;\r\n    }\r\n\r\n    return `BEGIN\r\n    DECLARE CONTINUE HANDLER FOR SQLSTATE VALUE '42710'\r\n      BEGIN END;\r\n      CREATE TABLE ${tableName.schema ? `\"${tableObject.schema}\".` : ''}\"${tableObject.table ? tableObject.table : tableObject.tableName}\" (${attributesClause});\r\n      END`;\r\n  }\r\n\r\n  dropTableQuery(tableName, options) {\r\n    let table = tableName;\r\n    let schema;\r\n\r\n    if (typeof table === 'object') {\r\n      schema = table.schema || undefined;\r\n      table = table.table;\r\n    } else if (options.schema) {\r\n      schema = options.schema;\r\n    }\r\n\r\n    return `DROP TABLE IF EXISTS ${schema ? `\"${schema}\".` : ''}\"${table}\"`;\r\n  }\r\n\r\n  describeTableQuery(tableName, schema) {\r\n\r\n    const sql\r\n    = `SELECT\r\n    QSYS2.SYSCOLUMNS.*,\r\n    QSYS2.SYSCST.CONSTRAINT_NAME,\r\n    QSYS2.SYSCST.CONSTRAINT_TYPE\r\n    FROM\r\n    QSYS2.SYSCOLUMNS\r\n    LEFT OUTER JOIN\r\n      QSYS2.SYSCSTCOL\r\n    ON\r\n      QSYS2.SYSCOLUMNS.TABLE_SCHEMA = QSYS2.SYSCSTCOL.TABLE_SCHEMA\r\n      AND\r\n      QSYS2.SYSCOLUMNS.TABLE_NAME = QSYS2.SYSCSTCOL.TABLE_NAME\r\n      AND\r\n      QSYS2.SYSCOLUMNS.COLUMN_NAME = QSYS2.SYSCSTCOL.COLUMN_NAME\r\n    LEFT JOIN\r\n      QSYS2.SYSCST\r\n    ON\r\n      QSYS2.SYSCSTCOL.CONSTRAINT_NAME = QSYS2.SYSCST.CONSTRAINT_NAME\r\n    WHERE QSYS2.SYSCOLUMNS.TABLE_SCHEMA = ${schema ? `'${schema}'` : 'CURRENT SCHEMA'} AND QSYS2.SYSCOLUMNS.TABLE_NAME = '${tableName}'`;\r\n\r\n    return sql;\r\n  }\r\n\r\n  showTablesQuery(schema) {\r\n    return `SELECT TABLE_NAME FROM SYSIBM.SQLTABLES WHERE TABLE_TYPE = 'TABLE' AND TABLE_SCHEM = ${schema ? `'${schema}'` : 'CURRENT SCHEMA'}`;\r\n  }\r\n\r\n  addColumnQuery(table, key, dataType) {\r\n    dataType.field = key;\r\n    const definition = this.attributeToSQL(dataType, {\r\n      context: 'addColumn',\r\n      tableName: table,\r\n      foreignKey: key,\r\n    });\r\n\r\n    return `ALTER TABLE ${this.quoteTable(table)} ADD ${this.quoteIdentifier(key)} ${definition}`;\r\n  }\r\n\r\n  removeColumnQuery(tableName, attributeName) {\r\n    return `ALTER TABLE ${this.quoteTable(tableName)} DROP COLUMN ${this.quoteIdentifier(attributeName)}`;\r\n  }\r\n\r\n  changeColumnQuery(tableName, attributes) {\r\n    const attrString = [];\r\n    const constraintString = [];\r\n\r\n    for (const attributeName in attributes) {\r\n      let definition = attributes[attributeName];\r\n      if (definition.includes('REFERENCES')) {\r\n        const attrName = this.quoteIdentifier(attributeName);\r\n        definition = definition.replace(/.+?(?=REFERENCES)/, '');\r\n        const foreignKey = this.quoteIdentifier(`${attributeName}`);\r\n        constraintString.push(`${foreignKey} FOREIGN KEY (${attrName}) ${definition}`);\r\n      } else {\r\n        attrString.push(`\"${attributeName}\" SET DATA TYPE ${definition}`);\r\n      }\r\n    }\r\n\r\n    let finalQuery = '';\r\n    if (attrString.length) {\r\n      finalQuery += `ALTER COLUMN ${attrString.join(', ')}`;\r\n      finalQuery += constraintString.length ? ' ' : '';\r\n    }\r\n\r\n    if (constraintString.length) {\r\n      finalQuery += `ADD CONSTRAINT ${constraintString.join(', ')}`;\r\n    }\r\n\r\n    return `ALTER TABLE ${this.quoteTable(tableName)} ${finalQuery}`;\r\n  }\r\n\r\n  renameTableQuery(before, after) {\r\n    return `RENAME TABLE ${this.quoteTable(before)} TO ${this.quoteTable(after)}`;\r\n  }\r\n\r\n  renameColumnQuery(tableName, attrBefore, attributes) {\r\n    const attrString = [];\r\n\r\n    for (const attrName in attributes) {\r\n      const definition = attributes[attrName];\r\n      attrString.push(`\\`${attrBefore}\\` \\`${attrName}\\` ${definition}`);\r\n    }\r\n\r\n    return `ALTER TABLE ${this.quoteTable(tableName)} RENAME COLUMN ${attrString.join(', ')};`;\r\n  }\r\n\r\n  handleSequelizeMethod(smth, tableName, factory, options, prepend) {\r\n    if (smth instanceof Utils.Json) {\r\n      // Parse nested object\r\n      if (smth.conditions) {\r\n        const conditions = this.parseConditionObject(smth.conditions).map(condition => `${this.quoteIdentifier(condition.path[0])}->>'$.${_.tail(condition.path).join('.')}' = '${condition.value}'`);\r\n\r\n        return conditions.join(' and ');\r\n      }\r\n\r\n      if (smth.path) {\r\n        let str;\r\n\r\n        // Allow specifying conditions using the sqlite json functions\r\n        if (this._checkValidJsonStatement(smth.path)) {\r\n          str = smth.path;\r\n        } else {\r\n          // Also support json dot notation\r\n          let path = smth.path;\r\n          let startWithDot = true;\r\n\r\n          // Convert .number. to [number].\r\n          path = path.replace(/\\.(\\d+)\\./g, '[$1].');\r\n          // Convert .number$ to [number]\r\n          path = path.replace(/\\.(\\d+)$/, '[$1]');\r\n\r\n          path = path.split('.');\r\n\r\n          let columnName = path.shift();\r\n          const match = columnName.match(/\\[\\d+\\]$/);\r\n          // If columnName ends with [\\d+]\r\n          if (match !== null) {\r\n            path.unshift(columnName.slice(match.index));\r\n            columnName = columnName.slice(0, Math.max(0, match.index));\r\n            startWithDot = false;\r\n          }\r\n\r\n          str = `${this.quoteIdentifier(columnName)}->>'$${startWithDot ? '.' : ''}${path.join('.')}'`;\r\n        }\r\n\r\n        if (smth.value) {\r\n          str += util.format(' = %s', this.escape(smth.value, undefined, { replacements: options.replacements }));\r\n        }\r\n\r\n        return str;\r\n      }\r\n    } else if (smth instanceof Utils.Cast) {\r\n      if (/timestamp/i.test(smth.type)) {\r\n        smth.type = 'timestamp';\r\n      } else if (smth.json && /boolean/i.test(smth.type)) {\r\n        // true or false cannot be casted as booleans within a JSON structure\r\n        smth.type = 'char';\r\n      } else if (/double precision/i.test(smth.type) || /boolean/i.test(smth.type) || /integer/i.test(smth.type)) {\r\n        smth.type = 'integer';\r\n      } else if (/text/i.test(smth.type)) {\r\n        smth.type = 'char';\r\n      }\r\n    }\r\n\r\n    return super.handleSequelizeMethod(smth, tableName, factory, options, prepend);\r\n  }\r\n\r\n  escape(value, field, options) {\r\n    options = options || {};\r\n\r\n    if (value !== null && value !== undefined) {\r\n      if (value instanceof Utils.SequelizeMethod) {\r\n        return this.handleSequelizeMethod(value, undefined, undefined, options);\r\n      }\r\n\r\n      if (field && field.type) {\r\n        this.validate(value, field, options);\r\n\r\n        if (field.type.stringify) {\r\n          // Users shouldn't have to worry about these args - just give them a function that takes a single arg\r\n          if (field.type._binary) {\r\n            field.type.escape = false;\r\n          }\r\n\r\n          const simpleEscape = escVal => SqlString.escape(escVal, this.options.timezone, this.dialect);\r\n\r\n          value = field.type.stringify(value, { escape: simpleEscape, field, timezone: this.options.timezone, operation: options.operation });\r\n\r\n          if (field.type.escape === false) {\r\n            // The data-type already did the required escaping\r\n            return value;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    const format = (value === null && options.where);\r\n\r\n    return SqlString.escape(value, this.options.timezone, this.dialect, format);\r\n  }\r\n\r\n  /*\r\n    Returns an add index query.\r\n    Parameters:\r\n      - tableName -> Name of an existing table, possibly with schema.\r\n      - options:\r\n        - type: UNIQUE|FULLTEXT|SPATIAL\r\n        - name: The name of the index. Default is <table>_<attr1>_<attr2>\r\n        - fields: An array of attributes as string or as hash.\r\n                  If the attribute is a hash, it must have the following content:\r\n                  - name: The name of the attribute/column\r\n                  - length: An integer. Optional\r\n                  - order: 'ASC' or 'DESC'. Optional\r\n        - parser\r\n        - using\r\n        - operator\r\n        - concurrently: Pass CONCURRENT so other operations run while the index is created\r\n      - rawTablename, the name of the table, without schema. Used to create the name of the index\r\n   @private\r\n  */\r\n  addIndexQuery(tableName, _attributes, _options, rawTablename) {\r\n    let options = _options || Object.create(null);\r\n\r\n    if (!Array.isArray(_attributes)) {\r\n      options = _attributes;\r\n    } else {\r\n      options.fields = _attributes;\r\n    }\r\n\r\n    options.prefix = options.prefix || rawTablename || tableName;\r\n    if (options.prefix && typeof options.prefix === 'string') {\r\n      options.prefix = options.prefix.replace(/\\./g, '_');\r\n      options.prefix = options.prefix.replace(/(\"|')/g, '');\r\n    }\r\n\r\n    const fieldsSql = options.fields.map(field => {\r\n      if (typeof field === 'string') {\r\n        return this.quoteIdentifier(field);\r\n      }\r\n\r\n      if (field instanceof Utils.SequelizeMethod) {\r\n        return this.handleSequelizeMethod(field);\r\n      }\r\n\r\n      let result = '';\r\n\r\n      if (field.attribute) {\r\n        field.name = field.attribute;\r\n      }\r\n\r\n      if (!field.name) {\r\n        throw new Error(`The following index field has no name: ${util.inspect(field)}`);\r\n      }\r\n\r\n      result += this.quoteIdentifier(field.name);\r\n\r\n      if (this._dialect.supports.index.length && field.length) {\r\n        result += `(${field.length})`;\r\n      }\r\n\r\n      if (field.order) {\r\n        result += ` ${field.order}`;\r\n      }\r\n\r\n      return result;\r\n    });\r\n\r\n    if (!options.name) {\r\n      // Mostly for cases where addIndex is called directly by the user without an options object (for example in migrations)\r\n      // All calls that go through sequelize should already have a name\r\n      options = Utils.nameIndex(options, options.prefix);\r\n    }\r\n\r\n    options = Model._conformIndex(options);\r\n\r\n    if (!this._dialect.supports.index.type) {\r\n      delete options.type;\r\n    }\r\n\r\n    if (options.where) {\r\n      options.where = this.whereQuery(options.where);\r\n    }\r\n\r\n    if (typeof tableName === 'string') {\r\n      tableName = this.quoteIdentifiers(tableName);\r\n    } else {\r\n      tableName = this.quoteTable(tableName);\r\n    }\r\n\r\n    let schema;\r\n    if (typeof options.schema === 'string') {\r\n      schema = this.quoteIdentifiers(options.schema);\r\n    }\r\n\r\n    // Although the function is 'addIndex', and the values are passed through\r\n    // the 'indexes' key of a table, Db2 for i doesn't allow REFERENCES to\r\n    // work against a UNIQUE INDEX, only a UNIQUE constraint.\r\n    if (options.unique) {\r\n      return `BEGIN\r\n      DECLARE CONTINUE HANDLER FOR SQLSTATE VALUE '42891'\r\n        BEGIN END;\r\n        ALTER TABLE ${tableName} ADD CONSTRAINT ${this.quoteIdentifiers(options.name)} UNIQUE (${fieldsSql.join(', ')}${options.operator ? ` ${options.operator}` : ''})${options.where ? ` ${options.where}` : ''};\r\n      END`;\r\n    }\r\n\r\n    return `CREATE${options.unique ? ' UNIQUE' : ''} INDEX ${schema ? ` ${schema}.` : ''}${this.quoteIdentifiers(options.name)} ON ${tableName} (${fieldsSql.join(', ')}${options.operator ? ` ${options.operator}` : ''})${options.where ? ` ${options.where}` : ''}`;\r\n  }\r\n\r\n  addConstraintQuery(tableName, options) {\r\n    const query = super.addConstraintQuery(tableName, options);\r\n\r\n    return query.replace(/;$/, '');\r\n  }\r\n\r\n  // _toJSONValue(value) {\r\n  //   // true/false are stored as strings in mysql\r\n  //   if (typeof value === 'boolean') {\r\n  //     return value.toString();\r\n  //   }\r\n\r\n  //   // null is stored as a string in mysql\r\n  //   if (value === null) {\r\n  //     return 'null';\r\n  //   }\r\n\r\n  //   return value;\r\n  // }\r\n\r\n  updateQuery(tableName, attrValueHash, where, options, columnDefinitions) {\r\n    const out = super.updateQuery(tableName, attrValueHash, where, options, columnDefinitions);\r\n\r\n    out.query = removeTrailingSemicolon(out.query);\r\n\r\n    return out;\r\n  }\r\n\r\n  arithmeticQuery(operator, tableName, where, incrementAmountsByField, extraAttributesToBeUpdated, options) {\r\n    return removeTrailingSemicolon(super.arithmeticQuery(operator, tableName, where, incrementAmountsByField, extraAttributesToBeUpdated, options));\r\n  }\r\n\r\n  upsertQuery(tableName, insertValues, updateValues, where, model, options) {\r\n    const aliasTable = `temp_${this.quoteTable(tableName)}`;\r\n\r\n    let query = `MERGE INTO ${this.quoteTable(tableName)} `;\r\n\r\n    const usingClause = `USING (\r\n      SELECT * FROM (${this.quoteTable(tableName)}\r\n      VALUES(42)\r\n      ) AS ${aliasTable}(\"id\") ON (${aliasTable}.\"id\" = ${this.quoteTable(tableName)}.\"id\")`;\r\n\r\n    query += usingClause;\r\n    query += ` WHEN MATCHED THEN ${this.updateQuery(tableName, tableName, where, options, updateValues)}\r\n    WHEN NOT MATCHED THEN ${this.insertQuery(tableName, insertValues, model, options).sql}`;\r\n\r\n    return query;\r\n  }\r\n\r\n  insertQuery(table, valueHash, modelAttributes, options) {\r\n    // remove the final semi-colon\r\n    const query = super.insertQuery(table, valueHash, modelAttributes, options);\r\n    if (query.query[query.query.length - 1] === ';') {\r\n      query.query = query.query.slice(0, -1);\r\n      query.query = `SELECT * FROM FINAL TABLE (${query.query})`;\r\n    }\r\n\r\n    return query;\r\n  }\r\n\r\n  selectQuery(tableName, options, model) {\r\n    // remove the final semi-colon\r\n    let query = super.selectQuery(tableName, options, model);\r\n    if (query[query.length - 1] === ';') {\r\n      query = query.slice(0, -1);\r\n    }\r\n\r\n    return query;\r\n  }\r\n\r\n  bulkInsertQuery(tableName, fieldValueHashes, options, fieldMappedAttributes) {\r\n    // remove the final semi-colon\r\n    let query = super.bulkInsertQuery(tableName, fieldValueHashes, options, fieldMappedAttributes);\r\n    if (query[query.length - 1] === ';') {\r\n      query = query.slice(0, -1);\r\n      query = `SELECT * FROM FINAL TABLE (${query})`;\r\n    }\r\n\r\n    return query;\r\n  }\r\n\r\n  truncateTableQuery(tableName) {\r\n    return `TRUNCATE TABLE ${this.quoteTable(tableName)} IMMEDIATE`;\r\n  }\r\n\r\n  deleteQuery(tableName, where, options = {}, model) {\r\n    let query = `DELETE FROM ${this.quoteTable(tableName)}`;\r\n\r\n    where = this.getWhereConditions(where, null, model, options);\r\n\r\n    if (where) {\r\n      query += ` WHERE ${where}`;\r\n    }\r\n\r\n    if (options.offset || options.limit) {\r\n      query += this.addLimitAndOffset(options, model);\r\n    }\r\n\r\n    return query;\r\n  }\r\n\r\n  /**\r\n   * Returns an SQL fragment for adding result constraints.\r\n   *\r\n   * @param  {object} options An object with selectQuery options.\r\n   * @returns {string}         The generated sql query.\r\n   * @private\r\n   */\r\n  addLimitAndOffset(options) {\r\n    let fragment = '';\r\n\r\n    if (options.offset) {\r\n      fragment += ` OFFSET ${this.escape(options.offset, undefined, options)} ROWS`;\r\n    }\r\n\r\n    if (options.limit) {\r\n      fragment += ` FETCH NEXT ${this.escape(options.limit, undefined, options)} ROWS ONLY`;\r\n    }\r\n\r\n    return fragment;\r\n  }\r\n\r\n  // Indexes and constraints\r\n\r\n  showIndexesQuery(tableName) {\r\n    let table;\r\n    let schema;\r\n    if (typeof tableName === 'string') {\r\n      table = tableName;\r\n    } else {\r\n      table = tableName.tableName || tableName.table;\r\n      schema = tableName.schema;\r\n    }\r\n\r\n    const sql\r\n    = `select\r\n      QSYS2.SYSCSTCOL.CONSTRAINT_NAME as NAME,\r\n      QSYS2.SYSCSTCOL.COLUMN_NAME,\r\n      QSYS2.SYSCST.CONSTRAINT_TYPE,\r\n      QSYS2.SYSCST.TABLE_SCHEMA,\r\n      QSYS2.SYSCST.TABLE_NAME\r\n    from\r\n      QSYS2.SYSCSTCOL\r\n    left outer join\r\n      QSYS2.SYSCST\r\n    on\r\n      QSYS2.SYSCSTCOL.TABLE_SCHEMA = QSYS2.SYSCST.TABLE_SCHEMA\r\n      and\r\n      QSYS2.SYSCSTCOL.TABLE_NAME = QSYS2.SYSCST.TABLE_NAME\r\n      and\r\n      QSYS2.SYSCSTCOL.CONSTRAINT_NAME = QSYS2.SYSCST.CONSTRAINT_NAME\r\n    where\r\n      QSYS2.SYSCSTCOL.TABLE_SCHEMA = ${schema ? `'${schema}'` : 'CURRENT SCHEMA'}\r\n      and\r\n      QSYS2.SYSCSTCOL.TABLE_NAME = '${table}'\r\n    union\r\n    select\r\n      QSYS2.SYSKEYS.INDEX_NAME AS NAME,\r\n      QSYS2.SYSKEYS.COLUMN_NAME,\r\n      CAST('INDEX' AS VARCHAR(11)),\r\n      QSYS2.SYSINDEXES.TABLE_SCHEMA,\r\n      QSYS2.SYSINDEXES.TABLE_NAME\r\n    from\r\n      QSYS2.SYSKEYS\r\n    left outer join\r\n      QSYS2.SYSINDEXES\r\n    on\r\n      QSYS2.SYSKEYS.INDEX_NAME = QSYS2.SYSINDEXES.INDEX_NAME\r\n    where\r\n      QSYS2.SYSINDEXES.TABLE_SCHEMA = ${schema ? `'${schema}'` : 'CURRENT SCHEMA'}\r\n      and\r\n      QSYS2.SYSINDEXES.TABLE_NAME = '${table}'`;\r\n\r\n    return sql;\r\n  }\r\n\r\n  showConstraintsQuery(table, constraintName) {\r\n    const tableName = table.tableName || table;\r\n    const schemaName = table.schema;\r\n\r\n    let sql = [\r\n      'SELECT CONSTRAINT_NAME AS \"constraintName\",',\r\n      'CONSTRAINT_SCHEMA AS \"constraintSchema\",',\r\n      'CONSTRAINT_TYPE AS \"constraintType\",',\r\n      'TABLE_NAME AS \"tableName\",',\r\n      'TABLE_SCHEMA AS \"tableSchema\"',\r\n      'from QSYS2.SYSCST',\r\n      `WHERE table_name='${tableName}'`,\r\n    ].join(' ');\r\n\r\n    if (constraintName) {\r\n      sql += ` AND CONSTRAINT_NAME = '${constraintName}'`;\r\n    }\r\n\r\n    if (schemaName) {\r\n      sql += ` AND TABLE_SCHEMA = '${schemaName}'`;\r\n    }\r\n\r\n    return sql;\r\n  }\r\n\r\n  removeIndexQuery(tableName, indexNameOrAttributes) {\r\n    let indexName = indexNameOrAttributes;\r\n\r\n    if (typeof indexName !== 'string') {\r\n      indexName = Utils.underscore(`${tableName}_${indexNameOrAttributes.join('_')}`);\r\n    }\r\n\r\n    return `BEGIN IF EXISTS (SELECT * FROM QSYS2.SYSINDEXES WHERE INDEX_NAME = '${indexName}') THEN DROP INDEX \"${indexName}\"; COMMIT; END IF; END`;\r\n  }\r\n\r\n  // bindParam(bind) {\r\n  //   return value => {\r\n  //     bind.push(value);\r\n\r\n  //     return '?';\r\n  //   };\r\n  // }\r\n\r\n  attributeToSQL(attribute, options) {\r\n    if (!_.isPlainObject(attribute)) {\r\n      attribute = {\r\n        type: attribute,\r\n      };\r\n    }\r\n\r\n    const attributeString = attribute.type.toString({ escape: this.escape.bind(this) });\r\n    let template = attributeString;\r\n\r\n    if (attribute.type instanceof DataTypes.ENUM) {\r\n      if (attribute.type.values && !attribute.values) {\r\n        attribute.values = attribute.type.values;\r\n      }\r\n\r\n      // enums are a special case\r\n      template = attribute.type.toSql();\r\n      if (options && options.context) {\r\n        template += options.context === 'changeColumn' ? ' ADD' : '';\r\n      }\r\n\r\n      template += ` CHECK (${this.quoteIdentifier(attribute.field)} IN(${attribute.values.map(value => {\r\n        return this.escape(value, undefined, { replacements: options?.replacements });\r\n      }).join(', ')}))`;\r\n    } else {\r\n      template = attribute.type.toString(options);\r\n    }\r\n\r\n    if (attribute.allowNull === false) {\r\n      template += ' NOT NULL';\r\n    } else if (attribute.allowNull === true && (options && options.context === 'changeColumn')) {\r\n      template += ' DROP NOT NULL';\r\n    }\r\n\r\n    if (attribute.autoIncrement) {\r\n      template += ' GENERATED BY DEFAULT AS IDENTITY (START WITH 1, INCREMENT BY 1)';\r\n    }\r\n\r\n    // BLOB cannot have a default value\r\n    if (!typeWithoutDefault.has(attributeString)\r\n      && attribute.type._binary !== true\r\n      && Utils.defaultValueSchemable(attribute.defaultValue)) {\r\n      if (attribute.defaultValue === true) {\r\n        attribute.defaultValue = 1;\r\n      } else if (attribute.defaultValue === false) {\r\n        attribute.defaultValue = 0;\r\n      }\r\n\r\n      template += ` DEFAULT ${this.escape(attribute.defaultValue, undefined, { replacements: options?.replacements })}`;\r\n    }\r\n\r\n    if (attribute.unique === true && !attribute.primaryKey) {\r\n      template += ' UNIQUE';\r\n    }\r\n\r\n    if (attribute.primaryKey) {\r\n      template += ' PRIMARY KEY';\r\n    }\r\n\r\n    // Db2 for i comments are a mess\r\n    // if (attribute.comment) {\r\n    //   template += ` ${options.context === 'changeColumn' ? 'ADD ' : ''}COMMENT ${this.escape(attribute.comment)}`;\r\n    // }\r\n\r\n    if (attribute.first) {\r\n      template += ' FIRST';\r\n    }\r\n\r\n    if (attribute.after) {\r\n      template += ` AFTER ${this.quoteIdentifier(attribute.after)}`;\r\n    }\r\n\r\n    if (attribute.references) {\r\n\r\n      if (options && options.context === 'addColumn' && options.foreignKey) {\r\n        const attrName = this.quoteIdentifier(options.foreignKey);\r\n        const fkName = this.quoteIdentifier(`${options.tableName}_${attrName}_foreign_idx`);\r\n\r\n        template += ` ADD CONSTRAINT ${fkName} FOREIGN KEY (${attrName})`;\r\n      }\r\n\r\n      template += ` REFERENCES ${this.quoteTable(attribute.references.model)}`;\r\n\r\n      if (attribute.references.key) {\r\n        template += ` (${this.quoteIdentifier(attribute.references.key)})`;\r\n      } else {\r\n        template += ` (${this.quoteIdentifier('id')})`;\r\n      }\r\n\r\n      if (attribute.onDelete) {\r\n        template += ` ON DELETE ${attribute.onDelete.toUpperCase()}`;\r\n      }\r\n\r\n      if (attribute.onUpdate && attribute.onUpdate.toUpperCase() !== 'CASCADE') {\r\n        template += ` ON UPDATE ${attribute.onUpdate.toUpperCase()}`;\r\n      }\r\n    }\r\n\r\n    return template;\r\n  }\r\n\r\n  attributesToSQL(attributes, options) {\r\n    const result = Object.create(null);\r\n\r\n    for (const key in attributes) {\r\n      const attribute = attributes[key];\r\n      attribute.field = attribute.field || key;\r\n      result[attribute.field || key] = this.attributeToSQL(attribute, options);\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Generates an SQL query that returns all foreign keys of a table.\r\n   *\r\n   * @param  {object} table  The table.\r\n   * @param  {string} schemaName The name of the schema.\r\n   * @returns {string}            The generated sql query.\r\n   * @private\r\n   */\r\n  getForeignKeysQuery(table, schemaName) {\r\n    const quotedSchemaName = schemaName ? wrapSingleQuote(schemaName) : 'CURRENT SCHEMA';\r\n    const quotedTableName = wrapSingleQuote(table.tableName || table);\r\n\r\n    const sql = [\r\n      'SELECT FK_NAME AS \"constraintName\",',\r\n      'PKTABLE_CAT AS \"referencedTableCatalog\",',\r\n      'PKTABLE_SCHEM AS \"referencedTableSchema\",',\r\n      'PKTABLE_NAME AS \"referencedTableName\",',\r\n      'PKCOLUMN_NAME AS \"referencedColumnName\",',\r\n      'FKTABLE_CAT AS \"tableCatalog\",',\r\n      'FKTABLE_SCHEM AS \"tableSchema\",',\r\n      'FKTABLE_NAME AS \"tableName\",',\r\n      'FKTABLE_SCHEM AS \"tableSchema\",',\r\n      'FKCOLUMN_NAME AS \"columnName\"',\r\n      'FROM SYSIBM.SQLFOREIGNKEYS',\r\n      `WHERE FKTABLE_SCHEM = ${quotedSchemaName}`,\r\n      `AND FKTABLE_NAME = ${quotedTableName}`,\r\n    ].join(' ');\r\n\r\n    return sql;\r\n  }\r\n\r\n  /**\r\n   * Generates an SQL query that returns the foreign key constraint of a given column.\r\n   *\r\n   * @param  {object} table  The table.\r\n   * @param  {string} columnName The name of the column.\r\n   * @returns {string}            The generated sql query.\r\n   * @private\r\n   */\r\n  getForeignKeyQuery(table, columnName) {\r\n    const quotedSchemaName = table.schema ? wrapSingleQuote(table.schema) : 'CURRENT SCHEMA';\r\n    const quotedTableName = wrapSingleQuote(table.tableName || table);\r\n    const quotedColumnName = wrapSingleQuote(columnName);\r\n\r\n    const sql = [\r\n      'SELECT FK_NAME AS \"constraintName\",',\r\n      'PKTABLE_CAT AS \"referencedTableCatalog\",',\r\n      'PKTABLE_SCHEM AS \"referencedTableSchema\",',\r\n      'PKTABLE_NAME AS \"referencedTableName\",',\r\n      'PKCOLUMN_NAME AS \"referencedColumnName\",',\r\n      'FKTABLE_CAT AS \"tableCatalog\",',\r\n      'FKTABLE_SCHEM AS \"tableSchema\",',\r\n      'FKTABLE_NAME AS \"tableName\",',\r\n      'FKTABLE_SCHEM AS \"tableSchema\",',\r\n      'FKCOLUMN_NAME AS \"columnName\"',\r\n      'FROM SYSIBM.SQLFOREIGNKEYS',\r\n      `WHERE FKTABLE_SCHEM = ${quotedSchemaName}`,\r\n      `AND FKTABLE_NAME = ${quotedTableName}`,\r\n      `AND FKCOLUMN_NAME = ${quotedColumnName}`,\r\n    ].join(' ');\r\n\r\n    return sql;\r\n  }\r\n\r\n  /**\r\n   * Generates an SQL query that removes a foreign key from a table.\r\n   *\r\n   * @param  {string} tableName  The name of the table.\r\n   * @param  {string} foreignKey The name of the foreign key constraint.\r\n   * @returns {string}            The generated sql query.\r\n   * @private\r\n   */\r\n  dropForeignKeyQuery(tableName, foreignKey) {\r\n    return `ALTER TABLE ${this.quoteTable(tableName)}\r\n      DROP FOREIGN KEY ${this.quoteIdentifier(foreignKey)};`;\r\n  }\r\n\r\n  booleanValue(value) {\r\n    if (value) {\r\n      return 1;\r\n    }\r\n\r\n    return 0;\r\n  }\r\n\r\n  quoteIdentifier(identifier, _force) {\r\n    return Utils.addTicks(Utils.removeTicks(identifier, '\"'), '\"');\r\n  }\r\n}\r\n\r\n// private methods\r\nfunction wrapSingleQuote(identifier) {\r\n  return Utils.addTicks(identifier, '\\'');\r\n}\r\n"],
  "mappings": "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",
  "names": []
}
