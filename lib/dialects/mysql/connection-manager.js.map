{
  "version": 3,
  "sources": ["../../../src/dialects/mysql/connection-manager.js"],
  "sourcesContent": ["'use strict';\r\n\r\nconst { ConnectionManager } = require('../abstract/connection-manager');\r\nconst SequelizeErrors = require('../../errors');\r\nconst { logger } = require('../../utils/logger');\r\nconst DataTypes = require('../../data-types').mysql;\r\nconst dayjs = require('dayjs');\r\n\r\nconst debug = logger.debugContext('connection:mysql');\r\nconst parserStore = require('../parserStore')('mysql');\r\nconst { promisify } = require('util');\r\n\r\n/**\r\n * MySQL Connection Manager\r\n *\r\n * Get connections, validate and disconnect them.\r\n * AbstractConnectionManager pooling use it to handle MySQL specific connections\r\n * Use https://github.com/sidorares/node-mysql2 to connect with MySQL server\r\n *\r\n * @private\r\n */\r\nexport class MySqlConnectionManager extends ConnectionManager {\r\n  constructor(dialect, sequelize) {\r\n    sequelize.config.port = sequelize.config.port || 3306;\r\n    super(dialect, sequelize);\r\n    this.lib = this._loadDialectModule('mysql2');\r\n    this.refreshTypeParser(DataTypes);\r\n  }\r\n\r\n  _refreshTypeParser(dataType) {\r\n    parserStore.refresh(dataType);\r\n  }\r\n\r\n  _clearTypeParser() {\r\n    parserStore.clear();\r\n  }\r\n\r\n  static _typecast(field, next) {\r\n    if (parserStore.get(field.type)) {\r\n      return parserStore.get(field.type)(field, this.sequelize.options, next);\r\n    }\r\n\r\n    return next();\r\n  }\r\n\r\n  /**\r\n   * Connect with MySQL database based on config, Handle any errors in connection\r\n   * Set the pool handlers on connection.error\r\n   * Also set proper timezone once connection is connected.\r\n   *\r\n   * @param {object} config\r\n   * @returns {Promise<Connection>}\r\n   * @private\r\n   */\r\n  async connect(config) {\r\n    const connectionConfig = {\r\n      host: config.host,\r\n      port: config.port,\r\n      user: config.username,\r\n      flags: '-FOUND_ROWS',\r\n      password: config.password,\r\n      database: config.database,\r\n      timezone: this.sequelize.options.timezone,\r\n      typeCast: MySqlConnectionManager._typecast.bind(this),\r\n      bigNumberStrings: false,\r\n      supportBigNumbers: true,\r\n      ...config.dialectOptions,\r\n    };\r\n\r\n    try {\r\n      const connection = await new Promise((resolve, reject) => {\r\n        const connection = this.lib.createConnection(connectionConfig);\r\n\r\n        const errorHandler = e => {\r\n          // clean up connect & error event if there is error\r\n          connection.removeListener('connect', connectHandler);\r\n          connection.removeListener('error', connectHandler);\r\n          reject(e);\r\n        };\r\n\r\n        const connectHandler = () => {\r\n          // clean up error event if connected\r\n          connection.removeListener('error', errorHandler);\r\n          resolve(connection);\r\n        };\r\n\r\n        // don't use connection.once for error event handling here\r\n        // mysql2 emit error two times in case handshake was failed\r\n        // first error is protocol_lost and second is timeout\r\n        // if we will use `once.error` node process will crash on 2nd error emit\r\n        connection.on('error', errorHandler);\r\n        connection.once('connect', connectHandler);\r\n      });\r\n\r\n      debug('connection acquired');\r\n      connection.on('error', error => {\r\n        switch (error.code) {\r\n          case 'ESOCKET':\r\n          case 'ECONNRESET':\r\n          case 'EPIPE':\r\n          case 'PROTOCOL_CONNECTION_LOST':\r\n            this.pool.destroy(connection);\r\n        }\r\n      });\r\n\r\n      if (!this.sequelize.config.keepDefaultTimezone) {\r\n        // set timezone for this connection\r\n        // but named timezone are not directly supported in mysql, so get its offset first\r\n        let tzOffset = this.sequelize.options.timezone;\r\n        tzOffset = /\\//.test(tzOffset) ? dayjs.tz(undefined, tzOffset).format('Z') : tzOffset;\r\n        await promisify(cb => connection.query(`SET time_zone = '${tzOffset}'`, cb))();\r\n      }\r\n\r\n      return connection;\r\n    } catch (error) {\r\n      switch (error.code) {\r\n        case 'ECONNREFUSED':\r\n          throw new SequelizeErrors.ConnectionRefusedError(error);\r\n        case 'ER_ACCESS_DENIED_ERROR':\r\n          throw new SequelizeErrors.AccessDeniedError(error);\r\n        case 'ENOTFOUND':\r\n          throw new SequelizeErrors.HostNotFoundError(error);\r\n        case 'EHOSTUNREACH':\r\n          throw new SequelizeErrors.HostNotReachableError(error);\r\n        case 'EINVAL':\r\n          throw new SequelizeErrors.InvalidConnectionError(error);\r\n        default:\r\n          throw new SequelizeErrors.ConnectionError(error);\r\n      }\r\n    }\r\n  }\r\n\r\n  async disconnect(connection) {\r\n    // Don't disconnect connections with CLOSED state\r\n    if (connection._closing) {\r\n      debug('connection tried to disconnect but was already at CLOSED state');\r\n\r\n      return;\r\n    }\r\n\r\n    return await promisify(callback => connection.end(callback))();\r\n  }\r\n\r\n  validate(connection) {\r\n    return connection\r\n      && !connection._fatalError\r\n      && !connection._protocolError\r\n      && !connection._closing\r\n      && !connection.stream.destroyed;\r\n  }\r\n}\r\n"],
  "mappings": "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",
  "names": []
}
