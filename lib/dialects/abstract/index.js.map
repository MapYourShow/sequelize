{
  "version": 3,
  "sources": ["../../../src/dialects/abstract/index.ts"],
  "sourcesContent": ["import type { Dialect } from '../../sequelize.js';\r\nimport type { AbstractQueryGenerator } from './query-generator.js';\r\nimport type { AbstractQuery } from './query.js';\r\n\r\nexport type DialectSupports = {\r\n  'DEFAULT': boolean,\r\n  'DEFAULT VALUES': boolean,\r\n  'VALUES ()': boolean,\r\n  'LIMIT ON UPDATE': boolean,\r\n  'ON DUPLICATE KEY': boolean,\r\n  'ORDER NULLS': boolean,\r\n  'UNION': boolean,\r\n  'UNION ALL': boolean,\r\n  'RIGHT JOIN': boolean,\r\n  EXCEPTION: boolean,\r\n\r\n  forShare?: 'LOCK IN SHARE MODE' | 'FOR SHARE' | undefined,\r\n  lock: boolean,\r\n  lockOf: boolean,\r\n  lockKey: boolean,\r\n  lockOuterJoinFailure: boolean,\r\n  skipLocked: boolean,\r\n  finalTable: boolean,\r\n\r\n  /* does the dialect support returning values for inserted/updated fields */\r\n  returnValues: false | {\r\n    output: boolean,\r\n    returning: boolean,\r\n  },\r\n\r\n  /* features specific to autoIncrement values */\r\n  autoIncrement: {\r\n    /* does the dialect require modification of insert queries when inserting auto increment fields */\r\n    identityInsert: boolean,\r\n\r\n    /* does the dialect support inserting default/null values for autoincrement fields */\r\n    defaultValue: boolean,\r\n\r\n    /* does the dialect support updating autoincrement fields */\r\n    update: boolean,\r\n  },\r\n  /* Do we need to say DEFAULT for bulk insert */\r\n  bulkDefault: boolean,\r\n  schemas: boolean,\r\n  transactions: boolean,\r\n  settingIsolationLevelDuringTransaction: boolean,\r\n  transactionOptions: {\r\n    type: boolean,\r\n  },\r\n  migrations: boolean,\r\n  upserts: boolean,\r\n  inserts: {\r\n    ignoreDuplicates: string, /* dialect specific words for INSERT IGNORE or DO NOTHING */\r\n    updateOnDuplicate: boolean | string, /* whether dialect supports ON DUPLICATE KEY UPDATE */\r\n    onConflictDoNothing: string, /* dialect specific words for ON CONFLICT DO NOTHING */\r\n    conflictFields: boolean, /* whether the dialect supports specifying conflict fields or not */\r\n  },\r\n  constraints: {\r\n    restrict: boolean,\r\n    addConstraint: boolean,\r\n    dropConstraint: boolean,\r\n    unique: boolean,\r\n    default: boolean,\r\n    check: boolean,\r\n    foreignKey: boolean,\r\n    primaryKey: boolean,\r\n    onUpdate: boolean,\r\n  },\r\n  index: {\r\n    collate: boolean,\r\n    length: boolean,\r\n    parser: boolean,\r\n    concurrently: boolean,\r\n    type: boolean,\r\n    using: boolean | number,\r\n    functionBased: boolean,\r\n    operator: boolean,\r\n    where: boolean,\r\n  },\r\n  groupedLimit: boolean,\r\n  indexViaAlter: boolean,\r\n  JSON: boolean,\r\n  JSONB: boolean,\r\n  ARRAY: boolean,\r\n  RANGE: boolean,\r\n  NUMERIC: boolean,\r\n  GEOMETRY: boolean,\r\n  GEOGRAPHY: boolean,\r\n  REGEXP: boolean,\r\n  /**\r\n   * Case-insensitive regexp operator support ('~*' in postgres).\r\n   */\r\n  IREGEXP: boolean,\r\n  HSTORE: boolean,\r\n  TSVECTOR: boolean,\r\n  deferrableConstraints: boolean,\r\n  tmpTableTrigger: boolean,\r\n  indexHints: boolean,\r\n  searchPath: boolean,\r\n};\r\n\r\nexport abstract class AbstractDialect {\r\n  /**\r\n   * List of features this dialect supports.\r\n   *\r\n   * Important: Dialect implementations inherit these values.\r\n   * When changing a default, ensure the implementations still properly declare which feature they support.\r\n   */\r\n  static readonly supports: DialectSupports = {\r\n    DEFAULT: true,\r\n    'DEFAULT VALUES': false,\r\n    'VALUES ()': false,\r\n    'LIMIT ON UPDATE': false,\r\n    'ON DUPLICATE KEY': true,\r\n    'ORDER NULLS': false,\r\n    UNION: true,\r\n    'UNION ALL': true,\r\n    'RIGHT JOIN': true,\r\n    EXCEPTION: false,\r\n    lock: false,\r\n    lockOf: false,\r\n    lockKey: false,\r\n    lockOuterJoinFailure: false,\r\n    skipLocked: false,\r\n    finalTable: false,\r\n    returnValues: false,\r\n    autoIncrement: {\r\n      identityInsert: false,\r\n      defaultValue: true,\r\n      update: true,\r\n    },\r\n    bulkDefault: false,\r\n    schemas: false,\r\n    transactions: true,\r\n    settingIsolationLevelDuringTransaction: true,\r\n    transactionOptions: {\r\n      type: false,\r\n    },\r\n    migrations: true,\r\n    upserts: true,\r\n    inserts: {\r\n      ignoreDuplicates: '',\r\n      updateOnDuplicate: false,\r\n      onConflictDoNothing: '',\r\n      conflictFields: false,\r\n    },\r\n    constraints: {\r\n      restrict: true,\r\n      addConstraint: true,\r\n      dropConstraint: true,\r\n      unique: true,\r\n      default: false,\r\n      check: true,\r\n      foreignKey: true,\r\n      primaryKey: true,\r\n      onUpdate: true,\r\n    },\r\n    index: {\r\n      collate: true,\r\n      length: false,\r\n      parser: false,\r\n      concurrently: false,\r\n      type: false,\r\n      using: true,\r\n      functionBased: false,\r\n      operator: false,\r\n      where: false,\r\n    },\r\n    groupedLimit: true,\r\n    indexViaAlter: false,\r\n    JSON: false,\r\n    JSONB: false,\r\n    NUMERIC: false,\r\n    ARRAY: false,\r\n    RANGE: false,\r\n    GEOMETRY: false,\r\n    REGEXP: false,\r\n    IREGEXP: false,\r\n    GEOGRAPHY: false,\r\n    HSTORE: false,\r\n    TSVECTOR: false,\r\n    deferrableConstraints: false,\r\n    tmpTableTrigger: false,\r\n    indexHints: false,\r\n    searchPath: false,\r\n  };\r\n\r\n  declare readonly defaultVersion: string;\r\n  declare readonly Query: typeof AbstractQuery;\r\n  declare readonly name: Dialect;\r\n  declare readonly TICK_CHAR: string;\r\n  declare readonly TICK_CHAR_LEFT: string;\r\n  declare readonly TICK_CHAR_RIGHT: string;\r\n  declare readonly queryGenerator: AbstractQueryGenerator;\r\n\r\n  get supports(): DialectSupports {\r\n    const Dialect = this.constructor as typeof AbstractDialect;\r\n\r\n    return Dialect.supports;\r\n  }\r\n\r\n  abstract createBindCollector(): BindCollector;\r\n}\r\n\r\nexport type BindCollector = {\r\n  /**\r\n   *\r\n   *\r\n   * @param {string} bindParameterName The name of the bind parameter\r\n   * @returns {string}\r\n   */\r\n  collect(bindParameterName: string): string,\r\n\r\n  /**\r\n   * Returns either an array of orders if the bind parameters are mapped to numeric parameters (e.g. '?', $1, @1),\r\n   * or null if no mapping was necessary because the dialect supports named parameters.\r\n   */\r\n  getBindParameterOrder(): string[] | null,\r\n};\r\n"],
  "mappings": ";;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAqGO,MAAe,gBAAgB;AAAA,SAOpB,WAA4B;AAAA,IAC1C,SAAS;AAAA,IACT,kBAAkB;AAAA,IAClB,aAAa;AAAA,IACb,mBAAmB;AAAA,IACnB,oBAAoB;AAAA,IACpB,eAAe;AAAA,IACf,OAAO;AAAA,IACP,aAAa;AAAA,IACb,cAAc;AAAA,IACd,WAAW;AAAA,IACX,MAAM;AAAA,IACN,QAAQ;AAAA,IACR,SAAS;AAAA,IACT,sBAAsB;AAAA,IACtB,YAAY;AAAA,IACZ,YAAY;AAAA,IACZ,cAAc;AAAA,IACd,eAAe;AAAA,MACb,gBAAgB;AAAA,MAChB,cAAc;AAAA,MACd,QAAQ;AAAA,IACV;AAAA,IACA,aAAa;AAAA,IACb,SAAS;AAAA,IACT,cAAc;AAAA,IACd,wCAAwC;AAAA,IACxC,oBAAoB;AAAA,MAClB,MAAM;AAAA,IACR;AAAA,IACA,YAAY;AAAA,IACZ,SAAS;AAAA,IACT,SAAS;AAAA,MACP,kBAAkB;AAAA,MAClB,mBAAmB;AAAA,MACnB,qBAAqB;AAAA,MACrB,gBAAgB;AAAA,IAClB;AAAA,IACA,aAAa;AAAA,MACX,UAAU;AAAA,MACV,eAAe;AAAA,MACf,gBAAgB;AAAA,MAChB,QAAQ;AAAA,MACR,SAAS;AAAA,MACT,OAAO;AAAA,MACP,YAAY;AAAA,MACZ,YAAY;AAAA,MACZ,UAAU;AAAA,IACZ;AAAA,IACA,OAAO;AAAA,MACL,SAAS;AAAA,MACT,QAAQ;AAAA,MACR,QAAQ;AAAA,MACR,cAAc;AAAA,MACd,MAAM;AAAA,MACN,OAAO;AAAA,MACP,eAAe;AAAA,MACf,UAAU;AAAA,MACV,OAAO;AAAA,IACT;AAAA,IACA,cAAc;AAAA,IACd,eAAe;AAAA,IACf,MAAM;AAAA,IACN,OAAO;AAAA,IACP,SAAS;AAAA,IACT,OAAO;AAAA,IACP,OAAO;AAAA,IACP,UAAU;AAAA,IACV,QAAQ;AAAA,IACR,SAAS;AAAA,IACT,WAAW;AAAA,IACX,QAAQ;AAAA,IACR,UAAU;AAAA,IACV,uBAAuB;AAAA,IACvB,iBAAiB;AAAA,IACjB,YAAY;AAAA,IACZ,YAAY;AAAA,EACd;AAAA,MAUI,WAA4B;AAC9B,UAAM,UAAU,KAAK;AAErB,WAAO,QAAQ;AAAA,EACjB;AAGF;",
  "names": []
}
