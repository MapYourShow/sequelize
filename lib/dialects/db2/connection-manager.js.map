{
  "version": 3,
  "sources": ["../../../src/dialects/db2/connection-manager.js"],
  "sourcesContent": ["'use strict';\r\n\r\nconst { ConnectionManager } = require('../abstract/connection-manager');\r\nconst sequelizeErrors = require('../../errors');\r\nconst { logger } = require('../../utils/logger');\r\nconst DataTypes = require('../../data-types').db2;\r\n\r\nconst debug = logger.debugContext('connection:db2');\r\nconst parserStore = require('../parserStore')('db2');\r\n\r\n/**\r\n * DB2 Connection Manager\r\n *\r\n * Get connections, validate and disconnect them.\r\n * AbstractConnectionManager pooling use it to handle DB2 specific connections\r\n * Use https://github.com/ibmdb/node-ibm_db to connect with DB2 server\r\n *\r\n * @private\r\n */\r\nexport class Db2ConnectionManager extends ConnectionManager {\r\n  constructor(dialect, sequelize) {\r\n    sequelize.config.port = sequelize.config.port || 3306;\r\n    super(dialect, sequelize);\r\n    this.lib = this._loadDialectModule('ibm_db');\r\n    this.refreshTypeParser(DataTypes);\r\n  }\r\n\r\n  static _typecast(field, next) {\r\n    if (parserStore.get(field.type)) {\r\n      return parserStore.get(field.type)(field, this.sequelize.options, next);\r\n    }\r\n\r\n    return next();\r\n  }\r\n\r\n  _refreshTypeParser(dataType) {\r\n    parserStore.refresh(dataType);\r\n  }\r\n\r\n  _clearTypeParser() {\r\n    parserStore.clear();\r\n  }\r\n\r\n  /**\r\n   * Connect with DB2 database based on config, Handle any errors in connection\r\n   * Set the pool handlers on connection.error\r\n   * Also set proper timezone once connection is connected.\r\n   *\r\n   * @param {object} config\r\n   * @returns {Promise<Connection>}\r\n   * @private\r\n   */\r\n  async connect(config) {\r\n    const connectionConfig = {\r\n      database: config.database,\r\n      hostname: config.host,\r\n      port: config.port,\r\n      uid: config.username,\r\n      pwd: config.password,\r\n    };\r\n\r\n    if (config.ssl) {\r\n      connectionConfig.security = config.ssl;\r\n    }\r\n\r\n    if (config.sslcertificate) {\r\n      connectionConfig.SSLServerCertificate = config.sslcertificate;\r\n    }\r\n\r\n    if (config.dialectOptions) {\r\n      for (const key of Object.keys(config.dialectOptions)) {\r\n        connectionConfig[key] = config.dialectOptions[key];\r\n      }\r\n    }\r\n\r\n    try {\r\n      return await new Promise((resolve, reject) => {\r\n        const connection = new this.lib.Database();\r\n        connection.lib = this.lib;\r\n        connection.open(connectionConfig, error => {\r\n          if (error) {\r\n            if (error.message && error.message.includes('SQL30081N')) {\r\n              return reject(new sequelizeErrors.ConnectionRefusedError(error));\r\n            }\r\n\r\n            return reject(new sequelizeErrors.ConnectionError(error));\r\n          }\r\n\r\n          return resolve(connection);\r\n        });\r\n      });\r\n    } catch (error) {\r\n      throw new sequelizeErrors.ConnectionError(error);\r\n    }\r\n  }\r\n\r\n  disconnect(connection) {\r\n    // Don't disconnect a connection that is already disconnected\r\n    if (connection.connected) {\r\n      connection.close(error => {\r\n        if (error) {\r\n          debug(error);\r\n        } else {\r\n          debug('connection closed');\r\n        }\r\n      });\r\n    }\r\n\r\n    return Promise.resolve();\r\n  }\r\n\r\n  validate(connection) {\r\n    return connection && connection.connected;\r\n  }\r\n\r\n  /**\r\n   * Call dialect library to disconnect a connection\r\n   *\r\n   * @param {Connection} connection\r\n   * @private\r\n   * @returns {Promise}\r\n   */\r\n  _disconnect(connection) {\r\n    return this.dialect.connectionManager.disconnect(connection);\r\n  }\r\n}\r\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA,MAAM,EAAE,sBAAsB,QAAQ,gCAAgC;AACtE,MAAM,kBAAkB,QAAQ,cAAc;AAC9C,MAAM,EAAE,WAAW,QAAQ,oBAAoB;AAC/C,MAAM,YAAY,QAAQ,kBAAkB,EAAE;AAE9C,MAAM,QAAQ,OAAO,aAAa,gBAAgB;AAClD,MAAM,cAAc,QAAQ,gBAAgB,EAAE,KAAK;AAW5C,MAAM,6BAA6B,kBAAkB;AAAA,EAC1D,YAAY,SAAS,WAAW;AAC9B,cAAU,OAAO,OAAO,UAAU,OAAO,QAAQ;AACjD,UAAM,SAAS,SAAS;AACxB,SAAK,MAAM,KAAK,mBAAmB,QAAQ;AAC3C,SAAK,kBAAkB,SAAS;AAAA,EAClC;AAAA,SAEO,UAAU,OAAO,MAAM;AAC5B,QAAI,YAAY,IAAI,MAAM,IAAI,GAAG;AAC/B,aAAO,YAAY,IAAI,MAAM,IAAI,EAAE,OAAO,KAAK,UAAU,SAAS,IAAI;AAAA,IACxE;AAEA,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,mBAAmB,UAAU;AAC3B,gBAAY,QAAQ,QAAQ;AAAA,EAC9B;AAAA,EAEA,mBAAmB;AACjB,gBAAY,MAAM;AAAA,EACpB;AAAA,QAWM,QAAQ,QAAQ;AACpB,UAAM,mBAAmB;AAAA,MACvB,UAAU,OAAO;AAAA,MACjB,UAAU,OAAO;AAAA,MACjB,MAAM,OAAO;AAAA,MACb,KAAK,OAAO;AAAA,MACZ,KAAK,OAAO;AAAA,IACd;AAEA,QAAI,OAAO,KAAK;AACd,uBAAiB,WAAW,OAAO;AAAA,IACrC;AAEA,QAAI,OAAO,gBAAgB;AACzB,uBAAiB,uBAAuB,OAAO;AAAA,IACjD;AAEA,QAAI,OAAO,gBAAgB;AACzB,iBAAW,OAAO,OAAO,KAAK,OAAO,cAAc,GAAG;AACpD,yBAAiB,OAAO,OAAO,eAAe;AAAA,MAChD;AAAA,IACF;AAEA,QAAI;AACF,aAAO,MAAM,IAAI,QAAQ,CAAC,SAAS,WAAW;AAC5C,cAAM,aAAa,IAAI,KAAK,IAAI,SAAS;AACzC,mBAAW,MAAM,KAAK;AACtB,mBAAW,KAAK,kBAAkB,WAAS;AACzC,cAAI,OAAO;AACT,gBAAI,MAAM,WAAW,MAAM,QAAQ,SAAS,WAAW,GAAG;AACxD,qBAAO,OAAO,IAAI,gBAAgB,uBAAuB,KAAK,CAAC;AAAA,YACjE;AAEA,mBAAO,OAAO,IAAI,gBAAgB,gBAAgB,KAAK,CAAC;AAAA,UAC1D;AAEA,iBAAO,QAAQ,UAAU;AAAA,QAC3B,CAAC;AAAA,MACH,CAAC;AAAA,IACH,SAAS,OAAP;AACA,YAAM,IAAI,gBAAgB,gBAAgB,KAAK;AAAA,IACjD;AAAA,EACF;AAAA,EAEA,WAAW,YAAY;AAErB,QAAI,WAAW,WAAW;AACxB,iBAAW,MAAM,WAAS;AACxB,YAAI,OAAO;AACT,gBAAM,KAAK;AAAA,QACb,OAAO;AACL,gBAAM,mBAAmB;AAAA,QAC3B;AAAA,MACF,CAAC;AAAA,IACH;AAEA,WAAO,QAAQ,QAAQ;AAAA,EACzB;AAAA,EAEA,SAAS,YAAY;AACnB,WAAO,cAAc,WAAW;AAAA,EAClC;AAAA,EASA,YAAY,YAAY;AACtB,WAAO,KAAK,QAAQ,kBAAkB,WAAW,UAAU;AAAA,EAC7D;AACF;",
  "names": []
}
