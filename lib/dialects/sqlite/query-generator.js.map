{
  "version": 3,
  "sources": ["../../../src/dialects/sqlite/query-generator.js"],
  "sourcesContent": ["'use strict';\r\n\r\nconst Utils = require('../../utils');\r\nconst { Transaction } = require('../../transaction');\r\nconst _ = require('lodash');\r\nconst { MySqlQueryGenerator } = require('../mysql/query-generator');\r\nconst { AbstractQueryGenerator } = require('../abstract/query-generator');\r\n\r\nexport class SqliteQueryGenerator extends MySqlQueryGenerator {\r\n  createSchema() {\r\n    return 'SELECT name FROM `sqlite_master` WHERE type=\\'table\\' and name!=\\'sqlite_sequence\\';';\r\n  }\r\n\r\n  showSchemasQuery() {\r\n    return 'SELECT name FROM `sqlite_master` WHERE type=\\'table\\' and name!=\\'sqlite_sequence\\';';\r\n  }\r\n\r\n  versionQuery() {\r\n    return 'SELECT sqlite_version() as `version`';\r\n  }\r\n\r\n  createTableQuery(tableName, attributes, options) {\r\n    options = options || {};\r\n\r\n    const primaryKeys = [];\r\n    const needsMultiplePrimaryKeys = Object.values(attributes).filter(definition => definition.includes('PRIMARY KEY')).length > 1;\r\n    const attrArray = [];\r\n\r\n    for (const attr in attributes) {\r\n      if (Object.prototype.hasOwnProperty.call(attributes, attr)) {\r\n        const dataType = attributes[attr];\r\n        const containsAutoIncrement = dataType.includes('AUTOINCREMENT');\r\n\r\n        let dataTypeString = dataType;\r\n        if (dataType.includes('PRIMARY KEY')) {\r\n          if (dataType.includes('INT')) {\r\n            // Only INTEGER is allowed for primary key, see https://github.com/sequelize/sequelize/issues/969 (no lenght, unsigned etc)\r\n            dataTypeString = containsAutoIncrement ? 'INTEGER PRIMARY KEY AUTOINCREMENT' : 'INTEGER PRIMARY KEY';\r\n\r\n            if (dataType.includes(' REFERENCES')) {\r\n              dataTypeString += dataType.slice(dataType.indexOf(' REFERENCES'));\r\n            }\r\n          }\r\n\r\n          if (needsMultiplePrimaryKeys) {\r\n            primaryKeys.push(attr);\r\n            if (dataType.includes('NOT NULL')) {\r\n              dataTypeString = dataType.replace(' PRIMARY KEY', '');\r\n            } else {\r\n              dataTypeString = dataType.replace('PRIMARY KEY', 'NOT NULL');\r\n            }\r\n          }\r\n        }\r\n\r\n        attrArray.push(`${this.quoteIdentifier(attr)} ${dataTypeString}`);\r\n      }\r\n    }\r\n\r\n    const table = this.quoteTable(tableName);\r\n    let attrStr = attrArray.join(', ');\r\n    const pkString = primaryKeys.map(pk => this.quoteIdentifier(pk)).join(', ');\r\n\r\n    if (options.uniqueKeys) {\r\n      _.each(options.uniqueKeys, columns => {\r\n        if (columns.customIndex) {\r\n          attrStr += `, UNIQUE (${columns.fields.map(field => this.quoteIdentifier(field)).join(', ')})`;\r\n        }\r\n      });\r\n    }\r\n\r\n    if (pkString.length > 0) {\r\n      attrStr += `, PRIMARY KEY (${pkString})`;\r\n    }\r\n\r\n    const sql = `CREATE TABLE IF NOT EXISTS ${table} (${attrStr});`;\r\n\r\n    return this.replaceBooleanDefaults(sql);\r\n  }\r\n\r\n  addLimitAndOffset(options, model) {\r\n    let fragment = '';\r\n    if (options.limit != null) {\r\n      fragment += ` LIMIT ${this.escape(options.limit, undefined, options)}`;\r\n    } else if (options.offset) {\r\n      // limit must be specified if offset is specified.\r\n      fragment += ` LIMIT -1`;\r\n    }\r\n\r\n    if (options.offset) {\r\n      fragment += ` OFFSET ${this.escape(options.offset, undefined, options)}`;\r\n    }\r\n\r\n    return fragment;\r\n  }\r\n\r\n  booleanValue(value) {\r\n    return value ? 1 : 0;\r\n  }\r\n\r\n  /**\r\n   * Check whether the statmement is json function or simple path\r\n   *\r\n   * @param   {string}  stmt  The statement to validate\r\n   * @returns {boolean}       true if the given statement is json function\r\n   * @throws  {Error}         throw if the statement looks like json function but has invalid token\r\n   */\r\n  _checkValidJsonStatement(stmt) {\r\n    if (typeof stmt !== 'string') {\r\n      return false;\r\n    }\r\n\r\n    // https://sqlite.org/json1.html\r\n    const jsonFunctionRegex = /^\\s*(json(?:_[a-z]+){0,2})\\([^)]*\\)/i;\r\n    const tokenCaptureRegex = /^\\s*((?:([\"'`])(?:(?!\\2).|\\2{2})*\\2)|[\\s\\w]+|[()+,.;-])/i;\r\n\r\n    let currentIndex = 0;\r\n    let openingBrackets = 0;\r\n    let closingBrackets = 0;\r\n    let hasJsonFunction = false;\r\n    let hasInvalidToken = false;\r\n\r\n    while (currentIndex < stmt.length) {\r\n      const string = stmt.slice(currentIndex);\r\n      const functionMatches = jsonFunctionRegex.exec(string);\r\n      if (functionMatches) {\r\n        currentIndex += functionMatches[0].indexOf('(');\r\n        hasJsonFunction = true;\r\n        continue;\r\n      }\r\n\r\n      const tokenMatches = tokenCaptureRegex.exec(string);\r\n      if (tokenMatches) {\r\n        const capturedToken = tokenMatches[1];\r\n        if (capturedToken === '(') {\r\n          openingBrackets++;\r\n        } else if (capturedToken === ')') {\r\n          closingBrackets++;\r\n        } else if (capturedToken === ';') {\r\n          hasInvalidToken = true;\r\n          break;\r\n        }\r\n\r\n        currentIndex += tokenMatches[0].length;\r\n        continue;\r\n      }\r\n\r\n      break;\r\n    }\r\n\r\n    // Check invalid json statement\r\n    hasInvalidToken |= openingBrackets !== closingBrackets;\r\n    if (hasJsonFunction && hasInvalidToken) {\r\n      throw new Error(`Invalid json statement: ${stmt}`);\r\n    }\r\n\r\n    // return true if the statement has valid json function\r\n    return hasJsonFunction;\r\n  }\r\n\r\n  // sqlite can't cast to datetime so we need to convert date values to their ISO strings\r\n  _toJSONValue(value) {\r\n    if (value instanceof Date) {\r\n      return value.toISOString();\r\n    }\r\n\r\n    if (Array.isArray(value) && value[0] instanceof Date) {\r\n      return value.map(val => val.toISOString());\r\n    }\r\n\r\n    return value;\r\n  }\r\n\r\n  handleSequelizeMethod(smth, tableName, factory, options, prepend) {\r\n    if (smth instanceof Utils.Json) {\r\n      return super.handleSequelizeMethod(smth, tableName, factory, options, prepend);\r\n    }\r\n\r\n    if (smth instanceof Utils.Cast && /timestamp/i.test(smth.type)) {\r\n      smth.type = 'datetime';\r\n    }\r\n\r\n    return AbstractQueryGenerator.prototype.handleSequelizeMethod.call(this, smth, tableName, factory, options, prepend);\r\n  }\r\n\r\n  addColumnQuery(table, key, dataType) {\r\n    const attributes = {};\r\n    attributes[key] = dataType;\r\n    const fields = this.attributesToSQL(attributes, { context: 'addColumn' });\r\n    const attribute = `${this.quoteIdentifier(key)} ${fields[key]}`;\r\n\r\n    const sql = `ALTER TABLE ${this.quoteTable(table)} ADD ${attribute};`;\r\n\r\n    return this.replaceBooleanDefaults(sql);\r\n  }\r\n\r\n  showTablesQuery() {\r\n    return 'SELECT name FROM `sqlite_master` WHERE type=\\'table\\' and name!=\\'sqlite_sequence\\';';\r\n  }\r\n\r\n  updateQuery(tableName, attrValueHash, where, options, attributes) {\r\n    options = options || {};\r\n    _.defaults(options, this.options);\r\n\r\n    attrValueHash = Utils.removeNullishValuesFromHash(attrValueHash, options.omitNull, options);\r\n\r\n    const modelAttributeMap = {};\r\n    const values = [];\r\n    const bind = Object.create(null);\r\n    const bindParam = options.bindParam === undefined ? this.bindParam(bind) : options.bindParam;\r\n\r\n    if (attributes) {\r\n      _.each(attributes, (attribute, key) => {\r\n        modelAttributeMap[key] = attribute;\r\n        if (attribute.field) {\r\n          modelAttributeMap[attribute.field] = attribute;\r\n        }\r\n      });\r\n    }\r\n\r\n    for (const key in attrValueHash) {\r\n      const value = attrValueHash[key];\r\n\r\n      if (value instanceof Utils.SequelizeMethod || options.bindParam === false) {\r\n        values.push(`${this.quoteIdentifier(key)}=${this.escape(value, modelAttributeMap && modelAttributeMap[key] || undefined, { context: 'UPDATE', replacements: options.replacements })}`);\r\n      } else {\r\n        values.push(`${this.quoteIdentifier(key)}=${this.format(value, modelAttributeMap && modelAttributeMap[key] || undefined, { context: 'UPDATE', replacements: options.replacements }, bindParam)}`);\r\n      }\r\n    }\r\n\r\n    let query;\r\n    const whereOptions = { ...options, bindParam };\r\n\r\n    if (options.limit) {\r\n      query = `UPDATE ${this.quoteTable(tableName)} SET ${values.join(',')} WHERE rowid IN (SELECT rowid FROM ${this.quoteTable(tableName)} ${this.whereQuery(where, whereOptions)} LIMIT ${this.escape(options.limit, undefined, options)})`.trim();\r\n    } else {\r\n      query = `UPDATE ${this.quoteTable(tableName)} SET ${values.join(',')} ${this.whereQuery(where, whereOptions)}`.trim();\r\n    }\r\n\r\n    const result = { query };\r\n    if (options.bindParam !== false) {\r\n      result.bind = bind;\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  truncateTableQuery(tableName, options = {}) {\r\n    return [\r\n      `DELETE FROM ${this.quoteTable(tableName)}`,\r\n      options.restartIdentity ? `; DELETE FROM ${this.quoteTable('sqlite_sequence')} WHERE ${this.quoteIdentifier('name')} = ${Utils.addTicks(Utils.removeTicks(this.quoteTable(tableName), '`'), '\\'')};` : '',\r\n    ].join('');\r\n  }\r\n\r\n  deleteQuery(tableName, where, options = {}, model) {\r\n    _.defaults(options, this.options);\r\n\r\n    let whereClause = this.getWhereConditions(where, null, model, options);\r\n\r\n    if (whereClause) {\r\n      whereClause = `WHERE ${whereClause}`;\r\n    }\r\n\r\n    if (options.limit) {\r\n      whereClause = `WHERE rowid IN (SELECT rowid FROM ${this.quoteTable(tableName)} ${whereClause} LIMIT ${this.escape(options.limit, undefined, options)})`;\r\n    }\r\n\r\n    return `DELETE FROM ${this.quoteTable(tableName)} ${whereClause}`.trim();\r\n  }\r\n\r\n  attributesToSQL(attributes, options) {\r\n    const result = {};\r\n    for (const name in attributes) {\r\n      const dataType = attributes[name];\r\n      const fieldName = dataType.field || name;\r\n\r\n      if (_.isObject(dataType)) {\r\n        let sql = dataType.type.toString();\r\n\r\n        if (dataType.allowNull === false) {\r\n          sql += ' NOT NULL';\r\n        }\r\n\r\n        if (Utils.defaultValueSchemable(dataType.defaultValue)) {\r\n          // TODO thoroughly check that DataTypes.NOW will properly\r\n          // get populated on all databases as DEFAULT value\r\n          // i.e. mysql requires: DEFAULT CURRENT_TIMESTAMP\r\n          sql += ` DEFAULT ${this.escape(dataType.defaultValue, dataType, options)}`;\r\n        }\r\n\r\n        if (dataType.unique === true) {\r\n          sql += ' UNIQUE';\r\n        }\r\n\r\n        if (dataType.primaryKey) {\r\n          sql += ' PRIMARY KEY';\r\n\r\n          if (dataType.autoIncrement) {\r\n            sql += ' AUTOINCREMENT';\r\n          }\r\n        }\r\n\r\n        if (dataType.references) {\r\n          const referencesTable = this.quoteTable(dataType.references.model);\r\n\r\n          let referencesKey;\r\n          if (dataType.references.key) {\r\n            referencesKey = this.quoteIdentifier(dataType.references.key);\r\n          } else {\r\n            referencesKey = this.quoteIdentifier('id');\r\n          }\r\n\r\n          sql += ` REFERENCES ${referencesTable} (${referencesKey})`;\r\n\r\n          if (dataType.onDelete) {\r\n            sql += ` ON DELETE ${dataType.onDelete.toUpperCase()}`;\r\n          }\r\n\r\n          if (dataType.onUpdate) {\r\n            sql += ` ON UPDATE ${dataType.onUpdate.toUpperCase()}`;\r\n          }\r\n\r\n        }\r\n\r\n        result[fieldName] = sql;\r\n      } else {\r\n        result[fieldName] = dataType;\r\n      }\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  showIndexesQuery(tableName) {\r\n    return `PRAGMA INDEX_LIST(${this.quoteTable(tableName)})`;\r\n  }\r\n\r\n  showConstraintsQuery(tableName, constraintName) {\r\n    let sql = `SELECT sql FROM sqlite_master WHERE tbl_name='${tableName}'`;\r\n\r\n    if (constraintName) {\r\n      sql += ` AND sql LIKE '%${constraintName}%'`;\r\n    }\r\n\r\n    return `${sql};`;\r\n  }\r\n\r\n  removeIndexQuery(tableName, indexNameOrAttributes) {\r\n    let indexName = indexNameOrAttributes;\r\n\r\n    if (typeof indexName !== 'string') {\r\n      indexName = Utils.underscore(`${tableName}_${indexNameOrAttributes.join('_')}`);\r\n    }\r\n\r\n    return `DROP INDEX IF EXISTS ${this.quoteIdentifier(indexName)}`;\r\n  }\r\n\r\n  describeTableQuery(tableName, schema, schemaDelimiter) {\r\n    const table = {\r\n      _schema: schema,\r\n      _schemaDelimiter: schemaDelimiter,\r\n      tableName,\r\n    };\r\n\r\n    return `PRAGMA TABLE_INFO(${this.quoteTable(this.addSchema(table))});`;\r\n  }\r\n\r\n  describeCreateTableQuery(tableName) {\r\n    return `SELECT sql FROM sqlite_master WHERE tbl_name='${tableName}';`;\r\n  }\r\n\r\n  removeColumnQuery(tableName, attributes) {\r\n\r\n    attributes = this.attributesToSQL(attributes);\r\n\r\n    let backupTableName;\r\n    if (typeof tableName === 'object') {\r\n      backupTableName = {\r\n        tableName: `${tableName.tableName}_backup`,\r\n        schema: tableName.schema,\r\n      };\r\n    } else {\r\n      backupTableName = `${tableName}_backup`;\r\n    }\r\n\r\n    const quotedTableName = this.quoteTable(tableName);\r\n    const quotedBackupTableName = this.quoteTable(backupTableName);\r\n    const attributeNames = Object.keys(attributes).map(attr => this.quoteIdentifier(attr)).join(', ');\r\n\r\n    // Temporary table cannot work for foreign keys.\r\n    return `${this.createTableQuery(backupTableName, attributes)\r\n    }INSERT INTO ${quotedBackupTableName} SELECT ${attributeNames} FROM ${quotedTableName};`\r\n      + `DROP TABLE ${quotedTableName};${\r\n        this.createTableQuery(tableName, attributes)\r\n      }INSERT INTO ${quotedTableName} SELECT ${attributeNames} FROM ${quotedBackupTableName};`\r\n      + `DROP TABLE ${quotedBackupTableName};`;\r\n  }\r\n\r\n  _alterConstraintQuery(tableName, attributes, createTableSql) {\r\n    let backupTableName;\r\n\r\n    attributes = this.attributesToSQL(attributes);\r\n\r\n    if (typeof tableName === 'object') {\r\n      backupTableName = {\r\n        tableName: `${tableName.tableName}_backup`,\r\n        schema: tableName.schema,\r\n      };\r\n    } else {\r\n      backupTableName = `${tableName}_backup`;\r\n    }\r\n\r\n    const quotedTableName = this.quoteTable(tableName);\r\n    const quotedBackupTableName = this.quoteTable(backupTableName);\r\n    const attributeNames = Object.keys(attributes).map(attr => this.quoteIdentifier(attr)).join(', ');\r\n\r\n    return `${createTableSql\r\n      .replace(`CREATE TABLE ${quotedTableName}`, `CREATE TABLE ${quotedBackupTableName}`)\r\n      .replace(`CREATE TABLE ${quotedTableName.replace(/`/g, '\"')}`, `CREATE TABLE ${quotedBackupTableName}`)\r\n    }INSERT INTO ${quotedBackupTableName} SELECT ${attributeNames} FROM ${quotedTableName};`\r\n      + `DROP TABLE ${quotedTableName};`\r\n      + `ALTER TABLE ${quotedBackupTableName} RENAME TO ${quotedTableName};`;\r\n  }\r\n\r\n  renameColumnQuery(tableName, attrNameBefore, attrNameAfter, attributes) {\r\n\r\n    let backupTableName;\r\n\r\n    attributes = this.attributesToSQL(attributes);\r\n\r\n    if (typeof tableName === 'object') {\r\n      backupTableName = {\r\n        tableName: `${tableName.tableName}_backup`,\r\n        schema: tableName.schema,\r\n      };\r\n    } else {\r\n      backupTableName = `${tableName}_backup`;\r\n    }\r\n\r\n    const quotedTableName = this.quoteTable(tableName);\r\n    const quotedBackupTableName = this.quoteTable(backupTableName);\r\n    const attributeNamesImport = Object.keys(attributes).map(attr => (attrNameAfter === attr ? `${this.quoteIdentifier(attrNameBefore)} AS ${this.quoteIdentifier(attr)}` : this.quoteIdentifier(attr))).join(', ');\r\n    const attributeNamesExport = Object.keys(attributes).map(attr => this.quoteIdentifier(attr)).join(', ');\r\n\r\n    // Temporary tables don't support foreign keys, so creating a temporary table will not allow foreign keys to be preserved\r\n    return `${this.createTableQuery(backupTableName, attributes)\r\n    }INSERT INTO ${quotedBackupTableName} SELECT ${attributeNamesImport} FROM ${quotedTableName};`\r\n      + `DROP TABLE ${quotedTableName};${\r\n        this.createTableQuery(tableName, attributes)\r\n      }INSERT INTO ${quotedTableName} SELECT ${attributeNamesExport} FROM ${quotedBackupTableName};`\r\n      + `DROP TABLE ${quotedBackupTableName};`;\r\n  }\r\n\r\n  startTransactionQuery(transaction) {\r\n    if (transaction.parent) {\r\n      return `SAVEPOINT ${this.quoteIdentifier(transaction.name)};`;\r\n    }\r\n\r\n    return `BEGIN ${transaction.options.type} TRANSACTION;`;\r\n  }\r\n\r\n  setIsolationLevelQuery(value) {\r\n    switch (value) {\r\n      case Transaction.ISOLATION_LEVELS.REPEATABLE_READ:\r\n        return '-- SQLite is not able to choose the isolation level REPEATABLE READ.';\r\n      case Transaction.ISOLATION_LEVELS.READ_UNCOMMITTED:\r\n        return 'PRAGMA read_uncommitted = ON;';\r\n      case Transaction.ISOLATION_LEVELS.READ_COMMITTED:\r\n        return 'PRAGMA read_uncommitted = OFF;';\r\n      case Transaction.ISOLATION_LEVELS.SERIALIZABLE:\r\n        return '-- SQLite\\'s default isolation level is SERIALIZABLE. Nothing to do.';\r\n      default:\r\n        throw new Error(`Unknown isolation level: ${value}`);\r\n    }\r\n  }\r\n\r\n  replaceBooleanDefaults(sql) {\r\n    return sql.replace(/DEFAULT '?false'?/g, 'DEFAULT 0').replace(/DEFAULT '?true'?/g, 'DEFAULT 1');\r\n  }\r\n\r\n  /**\r\n   * Generates an SQL query that returns all foreign keys of a table.\r\n   *\r\n   * @param  {string} tableName  The name of the table.\r\n   * @returns {string}            The generated sql query.\r\n   * @private\r\n   */\r\n  getForeignKeysQuery(tableName) {\r\n    return `PRAGMA foreign_key_list(${this.quoteTable(this.addSchema(tableName))})`;\r\n  }\r\n\r\n  /**\r\n   * Quote identifier in sql clause\r\n   *\r\n   * @param {string} identifier\r\n   * @param {boolean} force\r\n   *\r\n   * @returns {string}\r\n   */\r\n  quoteIdentifier(identifier, force) {\r\n    return Utils.addTicks(Utils.removeTicks(identifier, '`'), '`');\r\n  }\r\n\r\n  /**\r\n   * Generates an SQL query that extract JSON property of given path.\r\n   *\r\n   * @param   {string}               column  The JSON column\r\n   * @param   {string|Array<string>} [path]  The path to extract (optional)\r\n   * @param   {boolean}              [isJson] The value is JSON use alt symbols (optional)\r\n   * @returns {string}                       The generated sql query\r\n   * @private\r\n   */\r\n  jsonPathExtractionQuery(column, path, isJson) {\r\n    const quotedColumn = this.isIdentifierQuoted(column)\r\n      ? column\r\n      : this.quoteIdentifier(column);\r\n\r\n    const pathStr = this.escape(['$']\r\n      .concat(_.toPath(path))\r\n      .join('.')\r\n      .replace(/\\.(\\d+)(?:(?=\\.)|$)/g, (__, digit) => `[${digit}]`));\r\n\r\n    return `json_extract(${quotedColumn},${pathStr})`;\r\n  }\r\n}\r\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA,MAAM,QAAQ,QAAQ,aAAa;AACnC,MAAM,EAAE,gBAAgB,QAAQ,mBAAmB;AACnD,MAAM,IAAI,QAAQ,QAAQ;AAC1B,MAAM,EAAE,wBAAwB,QAAQ,0BAA0B;AAClE,MAAM,EAAE,2BAA2B,QAAQ,6BAA6B;AAEjE,MAAM,6BAA6B,oBAAoB;AAAA,EAC5D,eAAe;AACb,WAAO;AAAA,EACT;AAAA,EAEA,mBAAmB;AACjB,WAAO;AAAA,EACT;AAAA,EAEA,eAAe;AACb,WAAO;AAAA,EACT;AAAA,EAEA,iBAAiB,WAAW,YAAY,SAAS;AAC/C,cAAU,WAAW,CAAC;AAEtB,UAAM,cAAc,CAAC;AACrB,UAAM,2BAA2B,OAAO,OAAO,UAAU,EAAE,OAAO,gBAAc,WAAW,SAAS,aAAa,CAAC,EAAE,SAAS;AAC7H,UAAM,YAAY,CAAC;AAEnB,eAAW,QAAQ,YAAY;AAC7B,UAAI,OAAO,UAAU,eAAe,KAAK,YAAY,IAAI,GAAG;AAC1D,cAAM,WAAW,WAAW;AAC5B,cAAM,wBAAwB,SAAS,SAAS,eAAe;AAE/D,YAAI,iBAAiB;AACrB,YAAI,SAAS,SAAS,aAAa,GAAG;AACpC,cAAI,SAAS,SAAS,KAAK,GAAG;AAE5B,6BAAiB,wBAAwB,sCAAsC;AAE/E,gBAAI,SAAS,SAAS,aAAa,GAAG;AACpC,gCAAkB,SAAS,MAAM,SAAS,QAAQ,aAAa,CAAC;AAAA,YAClE;AAAA,UACF;AAEA,cAAI,0BAA0B;AAC5B,wBAAY,KAAK,IAAI;AACrB,gBAAI,SAAS,SAAS,UAAU,GAAG;AACjC,+BAAiB,SAAS,QAAQ,gBAAgB,EAAE;AAAA,YACtD,OAAO;AACL,+BAAiB,SAAS,QAAQ,eAAe,UAAU;AAAA,YAC7D;AAAA,UACF;AAAA,QACF;AAEA,kBAAU,KAAK,GAAG,KAAK,gBAAgB,IAAI,KAAK,gBAAgB;AAAA,MAClE;AAAA,IACF;AAEA,UAAM,QAAQ,KAAK,WAAW,SAAS;AACvC,QAAI,UAAU,UAAU,KAAK,IAAI;AACjC,UAAM,WAAW,YAAY,IAAI,QAAM,KAAK,gBAAgB,EAAE,CAAC,EAAE,KAAK,IAAI;AAE1E,QAAI,QAAQ,YAAY;AACtB,QAAE,KAAK,QAAQ,YAAY,aAAW;AACpC,YAAI,QAAQ,aAAa;AACvB,qBAAW,aAAa,QAAQ,OAAO,IAAI,WAAS,KAAK,gBAAgB,KAAK,CAAC,EAAE,KAAK,IAAI;AAAA,QAC5F;AAAA,MACF,CAAC;AAAA,IACH;AAEA,QAAI,SAAS,SAAS,GAAG;AACvB,iBAAW,kBAAkB;AAAA,IAC/B;AAEA,UAAM,MAAM,8BAA8B,UAAU;AAEpD,WAAO,KAAK,uBAAuB,GAAG;AAAA,EACxC;AAAA,EAEA,kBAAkB,SAAS,OAAO;AAChC,QAAI,WAAW;AACf,QAAI,QAAQ,SAAS,MAAM;AACzB,kBAAY,UAAU,KAAK,OAAO,QAAQ,OAAO,QAAW,OAAO;AAAA,IACrE,WAAW,QAAQ,QAAQ;AAEzB,kBAAY;AAAA,IACd;AAEA,QAAI,QAAQ,QAAQ;AAClB,kBAAY,WAAW,KAAK,OAAO,QAAQ,QAAQ,QAAW,OAAO;AAAA,IACvE;AAEA,WAAO;AAAA,EACT;AAAA,EAEA,aAAa,OAAO;AAClB,WAAO,QAAQ,IAAI;AAAA,EACrB;AAAA,EASA,yBAAyB,MAAM;AAC7B,QAAI,OAAO,SAAS,UAAU;AAC5B,aAAO;AAAA,IACT;AAGA,UAAM,oBAAoB;AAC1B,UAAM,oBAAoB;AAE1B,QAAI,eAAe;AACnB,QAAI,kBAAkB;AACtB,QAAI,kBAAkB;AACtB,QAAI,kBAAkB;AACtB,QAAI,kBAAkB;AAEtB,WAAO,eAAe,KAAK,QAAQ;AACjC,YAAM,SAAS,KAAK,MAAM,YAAY;AACtC,YAAM,kBAAkB,kBAAkB,KAAK,MAAM;AACrD,UAAI,iBAAiB;AACnB,wBAAgB,gBAAgB,GAAG,QAAQ,GAAG;AAC9C,0BAAkB;AAClB;AAAA,MACF;AAEA,YAAM,eAAe,kBAAkB,KAAK,MAAM;AAClD,UAAI,cAAc;AAChB,cAAM,gBAAgB,aAAa;AACnC,YAAI,kBAAkB,KAAK;AACzB;AAAA,QACF,WAAW,kBAAkB,KAAK;AAChC;AAAA,QACF,WAAW,kBAAkB,KAAK;AAChC,4BAAkB;AAClB;AAAA,QACF;AAEA,wBAAgB,aAAa,GAAG;AAChC;AAAA,MACF;AAEA;AAAA,IACF;AAGA,uBAAmB,oBAAoB;AACvC,QAAI,mBAAmB,iBAAiB;AACtC,YAAM,IAAI,MAAM,2BAA2B,MAAM;AAAA,IACnD;AAGA,WAAO;AAAA,EACT;AAAA,EAGA,aAAa,OAAO;AAClB,QAAI,iBAAiB,MAAM;AACzB,aAAO,MAAM,YAAY;AAAA,IAC3B;AAEA,QAAI,MAAM,QAAQ,KAAK,KAAK,MAAM,cAAc,MAAM;AACpD,aAAO,MAAM,IAAI,SAAO,IAAI,YAAY,CAAC;AAAA,IAC3C;AAEA,WAAO;AAAA,EACT;AAAA,EAEA,sBAAsB,MAAM,WAAW,SAAS,SAAS,SAAS;AAChE,QAAI,gBAAgB,MAAM,MAAM;AAC9B,aAAO,MAAM,sBAAsB,MAAM,WAAW,SAAS,SAAS,OAAO;AAAA,IAC/E;AAEA,QAAI,gBAAgB,MAAM,QAAQ,aAAa,KAAK,KAAK,IAAI,GAAG;AAC9D,WAAK,OAAO;AAAA,IACd;AAEA,WAAO,uBAAuB,UAAU,sBAAsB,KAAK,MAAM,MAAM,WAAW,SAAS,SAAS,OAAO;AAAA,EACrH;AAAA,EAEA,eAAe,OAAO,KAAK,UAAU;AACnC,UAAM,aAAa,CAAC;AACpB,eAAW,OAAO;AAClB,UAAM,SAAS,KAAK,gBAAgB,YAAY,EAAE,SAAS,YAAY,CAAC;AACxE,UAAM,YAAY,GAAG,KAAK,gBAAgB,GAAG,KAAK,OAAO;AAEzD,UAAM,MAAM,eAAe,KAAK,WAAW,KAAK,SAAS;AAEzD,WAAO,KAAK,uBAAuB,GAAG;AAAA,EACxC;AAAA,EAEA,kBAAkB;AAChB,WAAO;AAAA,EACT;AAAA,EAEA,YAAY,WAAW,eAAe,OAAO,SAAS,YAAY;AAChE,cAAU,WAAW,CAAC;AACtB,MAAE,SAAS,SAAS,KAAK,OAAO;AAEhC,oBAAgB,MAAM,4BAA4B,eAAe,QAAQ,UAAU,OAAO;AAE1F,UAAM,oBAAoB,CAAC;AAC3B,UAAM,SAAS,CAAC;AAChB,UAAM,OAAO,uBAAO,OAAO,IAAI;AAC/B,UAAM,YAAY,QAAQ,cAAc,SAAY,KAAK,UAAU,IAAI,IAAI,QAAQ;AAEnF,QAAI,YAAY;AACd,QAAE,KAAK,YAAY,CAAC,WAAW,QAAQ;AACrC,0BAAkB,OAAO;AACzB,YAAI,UAAU,OAAO;AACnB,4BAAkB,UAAU,SAAS;AAAA,QACvC;AAAA,MACF,CAAC;AAAA,IACH;AAEA,eAAW,OAAO,eAAe;AAC/B,YAAM,QAAQ,cAAc;AAE5B,UAAI,iBAAiB,MAAM,mBAAmB,QAAQ,cAAc,OAAO;AACzE,eAAO,KAAK,GAAG,KAAK,gBAAgB,GAAG,KAAK,KAAK,OAAO,OAAO,qBAAqB,kBAAkB,QAAQ,QAAW,EAAE,SAAS,UAAU,cAAc,QAAQ,aAAa,CAAC,GAAG;AAAA,MACvL,OAAO;AACL,eAAO,KAAK,GAAG,KAAK,gBAAgB,GAAG,KAAK,KAAK,OAAO,OAAO,qBAAqB,kBAAkB,QAAQ,QAAW,EAAE,SAAS,UAAU,cAAc,QAAQ,aAAa,GAAG,SAAS,GAAG;AAAA,MAClM;AAAA,IACF;AAEA,QAAI;AACJ,UAAM,eAAe,iCAAK,UAAL,EAAc,UAAU;AAE7C,QAAI,QAAQ,OAAO;AACjB,cAAQ,UAAU,KAAK,WAAW,SAAS,SAAS,OAAO,KAAK,GAAG,uCAAuC,KAAK,WAAW,SAAS,KAAK,KAAK,WAAW,OAAO,YAAY,WAAW,KAAK,OAAO,QAAQ,OAAO,QAAW,OAAO,KAAK,KAAK;AAAA,IAC/O,OAAO;AACL,cAAQ,UAAU,KAAK,WAAW,SAAS,SAAS,OAAO,KAAK,GAAG,KAAK,KAAK,WAAW,OAAO,YAAY,IAAI,KAAK;AAAA,IACtH;AAEA,UAAM,SAAS,EAAE,MAAM;AACvB,QAAI,QAAQ,cAAc,OAAO;AAC/B,aAAO,OAAO;AAAA,IAChB;AAEA,WAAO;AAAA,EACT;AAAA,EAEA,mBAAmB,WAAW,UAAU,CAAC,GAAG;AAC1C,WAAO;AAAA,MACL,eAAe,KAAK,WAAW,SAAS;AAAA,MACxC,QAAQ,kBAAkB,iBAAiB,KAAK,WAAW,iBAAiB,WAAW,KAAK,gBAAgB,MAAM,OAAO,MAAM,SAAS,MAAM,YAAY,KAAK,WAAW,SAAS,GAAG,GAAG,GAAG,GAAI,OAAO;AAAA,IACzM,EAAE,KAAK,EAAE;AAAA,EACX;AAAA,EAEA,YAAY,WAAW,OAAO,UAAU,CAAC,GAAG,OAAO;AACjD,MAAE,SAAS,SAAS,KAAK,OAAO;AAEhC,QAAI,cAAc,KAAK,mBAAmB,OAAO,MAAM,OAAO,OAAO;AAErE,QAAI,aAAa;AACf,oBAAc,SAAS;AAAA,IACzB;AAEA,QAAI,QAAQ,OAAO;AACjB,oBAAc,qCAAqC,KAAK,WAAW,SAAS,KAAK,qBAAqB,KAAK,OAAO,QAAQ,OAAO,QAAW,OAAO;AAAA,IACrJ;AAEA,WAAO,eAAe,KAAK,WAAW,SAAS,KAAK,cAAc,KAAK;AAAA,EACzE;AAAA,EAEA,gBAAgB,YAAY,SAAS;AACnC,UAAM,SAAS,CAAC;AAChB,eAAW,QAAQ,YAAY;AAC7B,YAAM,WAAW,WAAW;AAC5B,YAAM,YAAY,SAAS,SAAS;AAEpC,UAAI,EAAE,SAAS,QAAQ,GAAG;AACxB,YAAI,MAAM,SAAS,KAAK,SAAS;AAEjC,YAAI,SAAS,cAAc,OAAO;AAChC,iBAAO;AAAA,QACT;AAEA,YAAI,MAAM,sBAAsB,SAAS,YAAY,GAAG;AAItD,iBAAO,YAAY,KAAK,OAAO,SAAS,cAAc,UAAU,OAAO;AAAA,QACzE;AAEA,YAAI,SAAS,WAAW,MAAM;AAC5B,iBAAO;AAAA,QACT;AAEA,YAAI,SAAS,YAAY;AACvB,iBAAO;AAEP,cAAI,SAAS,eAAe;AAC1B,mBAAO;AAAA,UACT;AAAA,QACF;AAEA,YAAI,SAAS,YAAY;AACvB,gBAAM,kBAAkB,KAAK,WAAW,SAAS,WAAW,KAAK;AAEjE,cAAI;AACJ,cAAI,SAAS,WAAW,KAAK;AAC3B,4BAAgB,KAAK,gBAAgB,SAAS,WAAW,GAAG;AAAA,UAC9D,OAAO;AACL,4BAAgB,KAAK,gBAAgB,IAAI;AAAA,UAC3C;AAEA,iBAAO,eAAe,oBAAoB;AAE1C,cAAI,SAAS,UAAU;AACrB,mBAAO,cAAc,SAAS,SAAS,YAAY;AAAA,UACrD;AAEA,cAAI,SAAS,UAAU;AACrB,mBAAO,cAAc,SAAS,SAAS,YAAY;AAAA,UACrD;AAAA,QAEF;AAEA,eAAO,aAAa;AAAA,MACtB,OAAO;AACL,eAAO,aAAa;AAAA,MACtB;AAAA,IACF;AAEA,WAAO;AAAA,EACT;AAAA,EAEA,iBAAiB,WAAW;AAC1B,WAAO,qBAAqB,KAAK,WAAW,SAAS;AAAA,EACvD;AAAA,EAEA,qBAAqB,WAAW,gBAAgB;AAC9C,QAAI,MAAM,iDAAiD;AAE3D,QAAI,gBAAgB;AAClB,aAAO,mBAAmB;AAAA,IAC5B;AAEA,WAAO,GAAG;AAAA,EACZ;AAAA,EAEA,iBAAiB,WAAW,uBAAuB;AACjD,QAAI,YAAY;AAEhB,QAAI,OAAO,cAAc,UAAU;AACjC,kBAAY,MAAM,WAAW,GAAG,aAAa,sBAAsB,KAAK,GAAG,GAAG;AAAA,IAChF;AAEA,WAAO,wBAAwB,KAAK,gBAAgB,SAAS;AAAA,EAC/D;AAAA,EAEA,mBAAmB,WAAW,QAAQ,iBAAiB;AACrD,UAAM,QAAQ;AAAA,MACZ,SAAS;AAAA,MACT,kBAAkB;AAAA,MAClB;AAAA,IACF;AAEA,WAAO,qBAAqB,KAAK,WAAW,KAAK,UAAU,KAAK,CAAC;AAAA,EACnE;AAAA,EAEA,yBAAyB,WAAW;AAClC,WAAO,iDAAiD;AAAA,EAC1D;AAAA,EAEA,kBAAkB,WAAW,YAAY;AAEvC,iBAAa,KAAK,gBAAgB,UAAU;AAE5C,QAAI;AACJ,QAAI,OAAO,cAAc,UAAU;AACjC,wBAAkB;AAAA,QAChB,WAAW,GAAG,UAAU;AAAA,QACxB,QAAQ,UAAU;AAAA,MACpB;AAAA,IACF,OAAO;AACL,wBAAkB,GAAG;AAAA,IACvB;AAEA,UAAM,kBAAkB,KAAK,WAAW,SAAS;AACjD,UAAM,wBAAwB,KAAK,WAAW,eAAe;AAC7D,UAAM,iBAAiB,OAAO,KAAK,UAAU,EAAE,IAAI,UAAQ,KAAK,gBAAgB,IAAI,CAAC,EAAE,KAAK,IAAI;AAGhG,WAAO,GAAG,KAAK,iBAAiB,iBAAiB,UAAU,gBAC5C,gCAAgC,uBAAuB,8BACpD,mBACd,KAAK,iBAAiB,WAAW,UAAU,gBAC9B,0BAA0B,uBAAuB,oCAChD;AAAA,EACpB;AAAA,EAEA,sBAAsB,WAAW,YAAY,gBAAgB;AAC3D,QAAI;AAEJ,iBAAa,KAAK,gBAAgB,UAAU;AAE5C,QAAI,OAAO,cAAc,UAAU;AACjC,wBAAkB;AAAA,QAChB,WAAW,GAAG,UAAU;AAAA,QACxB,QAAQ,UAAU;AAAA,MACpB;AAAA,IACF,OAAO;AACL,wBAAkB,GAAG;AAAA,IACvB;AAEA,UAAM,kBAAkB,KAAK,WAAW,SAAS;AACjD,UAAM,wBAAwB,KAAK,WAAW,eAAe;AAC7D,UAAM,iBAAiB,OAAO,KAAK,UAAU,EAAE,IAAI,UAAQ,KAAK,gBAAgB,IAAI,CAAC,EAAE,KAAK,IAAI;AAEhG,WAAO,GAAG,eACP,QAAQ,gBAAgB,mBAAmB,gBAAgB,uBAAuB,EAClF,QAAQ,gBAAgB,gBAAgB,QAAQ,MAAM,GAAG,KAAK,gBAAgB,uBAAuB,gBACzF,gCAAgC,uBAAuB,8BACpD,+BACC,mCAAmC;AAAA,EACxD;AAAA,EAEA,kBAAkB,WAAW,gBAAgB,eAAe,YAAY;AAEtE,QAAI;AAEJ,iBAAa,KAAK,gBAAgB,UAAU;AAE5C,QAAI,OAAO,cAAc,UAAU;AACjC,wBAAkB;AAAA,QAChB,WAAW,GAAG,UAAU;AAAA,QACxB,QAAQ,UAAU;AAAA,MACpB;AAAA,IACF,OAAO;AACL,wBAAkB,GAAG;AAAA,IACvB;AAEA,UAAM,kBAAkB,KAAK,WAAW,SAAS;AACjD,UAAM,wBAAwB,KAAK,WAAW,eAAe;AAC7D,UAAM,uBAAuB,OAAO,KAAK,UAAU,EAAE,IAAI,UAAS,kBAAkB,OAAO,GAAG,KAAK,gBAAgB,cAAc,QAAQ,KAAK,gBAAgB,IAAI,MAAM,KAAK,gBAAgB,IAAI,CAAE,EAAE,KAAK,IAAI;AAC9M,UAAM,uBAAuB,OAAO,KAAK,UAAU,EAAE,IAAI,UAAQ,KAAK,gBAAgB,IAAI,CAAC,EAAE,KAAK,IAAI;AAGtG,WAAO,GAAG,KAAK,iBAAiB,iBAAiB,UAAU,gBAC5C,gCAAgC,6BAA6B,8BAC1D,mBACd,KAAK,iBAAiB,WAAW,UAAU,gBAC9B,0BAA0B,6BAA6B,oCACtD;AAAA,EACpB;AAAA,EAEA,sBAAsB,aAAa;AACjC,QAAI,YAAY,QAAQ;AACtB,aAAO,aAAa,KAAK,gBAAgB,YAAY,IAAI;AAAA,IAC3D;AAEA,WAAO,SAAS,YAAY,QAAQ;AAAA,EACtC;AAAA,EAEA,uBAAuB,OAAO;AAC5B,YAAQ;AAAA,WACD,YAAY,iBAAiB;AAChC,eAAO;AAAA,WACJ,YAAY,iBAAiB;AAChC,eAAO;AAAA,WACJ,YAAY,iBAAiB;AAChC,eAAO;AAAA,WACJ,YAAY,iBAAiB;AAChC,eAAO;AAAA;AAEP,cAAM,IAAI,MAAM,4BAA4B,OAAO;AAAA;AAAA,EAEzD;AAAA,EAEA,uBAAuB,KAAK;AAC1B,WAAO,IAAI,QAAQ,sBAAsB,WAAW,EAAE,QAAQ,qBAAqB,WAAW;AAAA,EAChG;AAAA,EASA,oBAAoB,WAAW;AAC7B,WAAO,2BAA2B,KAAK,WAAW,KAAK,UAAU,SAAS,CAAC;AAAA,EAC7E;AAAA,EAUA,gBAAgB,YAAY,OAAO;AACjC,WAAO,MAAM,SAAS,MAAM,YAAY,YAAY,GAAG,GAAG,GAAG;AAAA,EAC/D;AAAA,EAWA,wBAAwB,QAAQ,MAAM,QAAQ;AAC5C,UAAM,eAAe,KAAK,mBAAmB,MAAM,IAC/C,SACA,KAAK,gBAAgB,MAAM;AAE/B,UAAM,UAAU,KAAK,OAAO,CAAC,GAAG,EAC7B,OAAO,EAAE,OAAO,IAAI,CAAC,EACrB,KAAK,GAAG,EACR,QAAQ,wBAAwB,CAAC,IAAI,UAAU,IAAI,QAAQ,CAAC;AAE/D,WAAO,gBAAgB,gBAAgB;AAAA,EACzC;AACF;",
  "names": []
}
