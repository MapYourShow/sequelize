{
  "version": 3,
  "sources": ["../../../src/dialects/sqlite/query.js"],
  "sourcesContent": ["'use strict';\r\n\r\nimport isPlainObject from 'lodash/isPlainObject';\r\n\r\nconst _ = require('lodash');\r\nconst Utils = require('../../utils');\r\nconst { AbstractQuery } = require('../abstract/query');\r\nconst { QueryTypes } = require('../../query-types');\r\nconst sequelizeErrors = require('../../errors');\r\nconst parserStore = require('../parserStore')('sqlite');\r\nconst { logger } = require('../../utils/logger');\r\n\r\nconst debug = logger.debugContext('sql:sqlite');\r\n\r\n// sqlite3 currently ignores bigint values, so we have to translate to string for now\r\n// There's a WIP here: https://github.com/TryGhost/node-sqlite3/pull/1501\r\nfunction stringifyIfBigint(value) {\r\n  if (typeof value === 'bigint') {\r\n    return value.toString();\r\n  }\r\n\r\n  return value;\r\n}\r\n\r\nexport class SqliteQuery extends AbstractQuery {\r\n  getInsertIdField() {\r\n    return 'lastID';\r\n  }\r\n\r\n  _collectModels(include, prefix) {\r\n    const ret = {};\r\n\r\n    if (include) {\r\n      for (const _include of include) {\r\n        let key;\r\n        if (!prefix) {\r\n          key = _include.as;\r\n        } else {\r\n          key = `${prefix}.${_include.as}`;\r\n        }\r\n\r\n        ret[key] = _include.model;\r\n\r\n        if (_include.include) {\r\n          _.merge(ret, this._collectModels(_include.include, key));\r\n        }\r\n      }\r\n    }\r\n\r\n    return ret;\r\n  }\r\n\r\n  _handleQueryResponse(metaData, columnTypes, err, results, errStack) {\r\n    if (err) {\r\n      err.sql = this.sql;\r\n      throw this.formatError(err, errStack);\r\n    }\r\n\r\n    let result = this.instance;\r\n\r\n    // add the inserted row id to the instance\r\n    if (this.isInsertQuery(results, metaData) || this.isUpsertQuery()) {\r\n      this.handleInsertQuery(results, metaData);\r\n      if (!this.instance) {\r\n        // handle bulkCreate AI primary key\r\n        if (\r\n          metaData.constructor.name === 'Statement'\r\n          && this.model\r\n          && this.model.autoIncrementAttribute\r\n          && this.model.autoIncrementAttribute === this.model.primaryKeyAttribute\r\n          && this.model.rawAttributes[this.model.primaryKeyAttribute]\r\n        ) {\r\n          const startId = metaData[this.getInsertIdField()] - metaData.changes + 1;\r\n          result = [];\r\n          for (let i = startId; i < startId + metaData.changes; i++) {\r\n            result.push({ [this.model.rawAttributes[this.model.primaryKeyAttribute].field]: i });\r\n          }\r\n        } else {\r\n          result = metaData[this.getInsertIdField()];\r\n        }\r\n      }\r\n    }\r\n\r\n    if (this.isShowTablesQuery()) {\r\n      return results.map(row => row.name);\r\n    }\r\n\r\n    if (this.isShowConstraintsQuery()) {\r\n      result = results;\r\n      if (results && results[0] && results[0].sql) {\r\n        result = this.parseConstraintsFromSql(results[0].sql);\r\n      }\r\n\r\n      return result;\r\n    }\r\n\r\n    if (this.isSelectQuery()) {\r\n      if (this.options.raw) {\r\n        return this.handleSelectQuery(results);\r\n      }\r\n\r\n      // This is a map of prefix strings to models, e.g. user.projects -> Project model\r\n      const prefixes = this._collectModels(this.options.include);\r\n\r\n      results = results.map(result => {\r\n        return _.mapValues(result, (value, name) => {\r\n          let model;\r\n          if (name.includes('.')) {\r\n            const lastind = name.lastIndexOf('.');\r\n\r\n            model = prefixes[name.slice(0, Math.max(0, lastind))];\r\n\r\n            name = name.slice(lastind + 1);\r\n          } else {\r\n            model = this.options.model;\r\n          }\r\n\r\n          const tableName = model.getTableName().toString().replace(/`/g, '');\r\n          const tableTypes = columnTypes[tableName] || {};\r\n\r\n          if (tableTypes && !(name in tableTypes)) {\r\n            // The column is aliased\r\n            _.forOwn(model.rawAttributes, (attribute, key) => {\r\n              if (name === key && attribute.field) {\r\n                name = attribute.field;\r\n\r\n                return false;\r\n              }\r\n            });\r\n          }\r\n\r\n          return Object.prototype.hasOwnProperty.call(tableTypes, name)\r\n            ? this.applyParsers(tableTypes[name], value)\r\n            : value;\r\n        });\r\n      });\r\n\r\n      return this.handleSelectQuery(results);\r\n    }\r\n\r\n    if (this.isShowOrDescribeQuery()) {\r\n      return results;\r\n    }\r\n\r\n    if (this.sql.includes('PRAGMA INDEX_LIST')) {\r\n      return this.handleShowIndexesQuery(results);\r\n    }\r\n\r\n    if (this.sql.includes('PRAGMA INDEX_INFO')) {\r\n      return results;\r\n    }\r\n\r\n    if (this.sql.includes('PRAGMA TABLE_INFO')) {\r\n      // this is the sqlite way of getting the metadata of a table\r\n      result = {};\r\n\r\n      let defaultValue;\r\n      for (const _result of results) {\r\n        if (_result.dflt_value === null) {\r\n          // Column schema omits any \"DEFAULT ...\"\r\n          defaultValue = undefined;\r\n        } else if (_result.dflt_value === 'NULL') {\r\n          // Column schema is a \"DEFAULT NULL\"\r\n          defaultValue = null;\r\n        } else {\r\n          defaultValue = _result.dflt_value;\r\n        }\r\n\r\n        result[_result.name] = {\r\n          type: _result.type,\r\n          allowNull: _result.notnull === 0,\r\n          defaultValue,\r\n          primaryKey: _result.pk !== 0,\r\n        };\r\n\r\n        if (result[_result.name].type === 'TINYINT(1)') {\r\n          result[_result.name].defaultValue = { 0: false, 1: true }[result[_result.name].defaultValue];\r\n        }\r\n\r\n        if (typeof result[_result.name].defaultValue === 'string') {\r\n          result[_result.name].defaultValue = result[_result.name].defaultValue.replace(/'/g, '');\r\n        }\r\n      }\r\n\r\n      return result;\r\n    }\r\n\r\n    if (this.sql.includes('PRAGMA foreign_keys;')) {\r\n      return results[0];\r\n    }\r\n\r\n    if (this.sql.includes('PRAGMA foreign_keys')) {\r\n      return results;\r\n    }\r\n\r\n    if (this.sql.includes('PRAGMA foreign_key_list')) {\r\n      return results;\r\n    }\r\n\r\n    if ([QueryTypes.BULKUPDATE, QueryTypes.BULKDELETE].includes(this.options.type)) {\r\n      return metaData.changes;\r\n    }\r\n\r\n    if (this.options.type === QueryTypes.VERSION) {\r\n      return results[0].version;\r\n    }\r\n\r\n    if (this.options.type === QueryTypes.RAW) {\r\n      return [results, metaData];\r\n    }\r\n\r\n    if (this.isUpsertQuery()) {\r\n      return [result, null];\r\n    }\r\n\r\n    if (this.isUpdateQuery() || this.isInsertQuery()) {\r\n      return [result, metaData.changes];\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  async run(sql, parameters) {\r\n    const conn = this.connection;\r\n    this.sql = sql;\r\n    const method = this.getDatabaseMethod();\r\n    const complete = this._logQuery(sql, debug, parameters);\r\n\r\n    return new Promise((resolve, reject) => {\r\n      conn.serialize(async () => {\r\n        const columnTypes = {};\r\n        const errForStack = new Error();\r\n        const executeSql = () => {\r\n          if (sql.startsWith('-- ')) {\r\n            return resolve();\r\n          }\r\n\r\n          const query = this;\r\n\r\n          // cannot use arrow function here because the function is bound to the statement\r\n          function afterExecute(executionError, results) {\r\n            try {\r\n              complete();\r\n              // `this` is passed from sqlite, we have no control over this.\r\n\r\n              resolve(query._handleQueryResponse(this, columnTypes, executionError, results, errForStack.stack));\r\n\r\n              return;\r\n            } catch (error) {\r\n              reject(error);\r\n            }\r\n          }\r\n\r\n          if (!parameters) {\r\n            parameters = [];\r\n          }\r\n\r\n          if (isPlainObject(parameters)) {\r\n            const newParameters = Object.create(null);\r\n\r\n            for (const key of Object.keys(parameters)) {\r\n              newParameters[`$${key}`] = stringifyIfBigint(parameters[key]);\r\n            }\r\n\r\n            parameters = newParameters;\r\n          } else {\r\n            parameters = parameters.map(stringifyIfBigint);\r\n          }\r\n\r\n          conn[method](sql, parameters, afterExecute);\r\n\r\n          return null;\r\n        };\r\n\r\n        if (this.getDatabaseMethod() === 'all') {\r\n          let tableNames = [];\r\n          if (this.options && this.options.tableNames) {\r\n            tableNames = this.options.tableNames;\r\n          } else if (/from `(.*?)`/i.test(this.sql)) {\r\n            tableNames.push(/from `(.*?)`/i.exec(this.sql)[1]);\r\n          }\r\n\r\n          // If we already have the metadata for the table, there's no need to ask for it again\r\n          tableNames = tableNames.filter(tableName => !(tableName in columnTypes) && tableName !== 'sqlite_master');\r\n\r\n          if (tableNames.length === 0) {\r\n            return executeSql();\r\n          }\r\n\r\n          await Promise.all(tableNames.map(tableName => new Promise(resolve => {\r\n            tableName = tableName.replace(/`/g, '');\r\n            columnTypes[tableName] = {};\r\n\r\n            conn.all(`PRAGMA table_info(\\`${tableName}\\`)`, (err, results) => {\r\n              if (!err) {\r\n                for (const result of results) {\r\n                  columnTypes[tableName][result.name] = result.type;\r\n                }\r\n              }\r\n\r\n              resolve();\r\n            });\r\n          })));\r\n        }\r\n\r\n        return executeSql();\r\n      });\r\n    });\r\n  }\r\n\r\n  parseConstraintsFromSql(sql) {\r\n    let constraints = sql.split('CONSTRAINT ');\r\n    let referenceTableName; let referenceTableKeys; let updateAction; let deleteAction;\r\n    constraints.splice(0, 1);\r\n    constraints = constraints.map(constraintSql => {\r\n      // Parse foreign key snippets\r\n      if (constraintSql.includes('REFERENCES')) {\r\n        // Parse out the constraint condition form sql string\r\n        updateAction = constraintSql.match(/ON UPDATE (CASCADE|SET NULL|RESTRICT|NO ACTION|SET DEFAULT)/);\r\n        deleteAction = constraintSql.match(/ON DELETE (CASCADE|SET NULL|RESTRICT|NO ACTION|SET DEFAULT)/);\r\n\r\n        if (updateAction) {\r\n          updateAction = updateAction[1];\r\n        }\r\n\r\n        if (deleteAction) {\r\n          deleteAction = deleteAction[1];\r\n        }\r\n\r\n        const referencesRegex = /REFERENCES.+\\((?:[^()]+|\\((?:[^()]+|\\([^()]*\\))*\\))*\\)/;\r\n        const referenceConditions = constraintSql.match(referencesRegex)[0].split(' ');\r\n        referenceTableName = Utils.removeTicks(referenceConditions[1]);\r\n        let columnNames = referenceConditions[2];\r\n        columnNames = columnNames.replace(/\\(|\\)/g, '').split(', ');\r\n        referenceTableKeys = columnNames.map(column => Utils.removeTicks(column));\r\n      }\r\n\r\n      const constraintCondition = constraintSql.match(/\\((?:[^()]+|\\((?:[^()]+|\\([^()]*\\))*\\))*\\)/)[0];\r\n      constraintSql = constraintSql.replace(/\\(.+\\)/, '');\r\n      const constraint = constraintSql.split(' ');\r\n\r\n      if (['PRIMARY', 'FOREIGN'].includes(constraint[1])) {\r\n        constraint[1] += ' KEY';\r\n      }\r\n\r\n      return {\r\n        constraintName: Utils.removeTicks(constraint[0]),\r\n        constraintType: constraint[1],\r\n        updateAction,\r\n        deleteAction,\r\n        sql: sql.replace(/\"/g, '`'), // Sqlite returns double quotes for table name\r\n        constraintCondition,\r\n        referenceTableName,\r\n        referenceTableKeys,\r\n      };\r\n    });\r\n\r\n    return constraints;\r\n  }\r\n\r\n  applyParsers(type, value) {\r\n    if (type.includes('(')) {\r\n      // Remove the length part\r\n      type = type.slice(0, Math.max(0, type.indexOf('(')));\r\n    }\r\n\r\n    type = type.replace('UNSIGNED', '').replace('ZEROFILL', '');\r\n    type = type.trim().toUpperCase();\r\n    const parse = parserStore.get(type);\r\n\r\n    if (value !== null && parse) {\r\n      return parse(value, { timezone: this.sequelize.options.timezone });\r\n    }\r\n\r\n    return value;\r\n  }\r\n\r\n  formatError(err, errStack) {\r\n\r\n    switch (err.code) {\r\n      case 'SQLITE_CONSTRAINT_UNIQUE':\r\n      case 'SQLITE_CONSTRAINT_PRIMARYKEY':\r\n      case 'SQLITE_CONSTRAINT_TRIGGER':\r\n      case 'SQLITE_CONSTRAINT_FOREIGNKEY':\r\n      case 'SQLITE_CONSTRAINT': {\r\n        if (err.message.includes('FOREIGN KEY constraint failed')) {\r\n          return new sequelizeErrors.ForeignKeyConstraintError({\r\n            cause: err,\r\n            stack: errStack,\r\n          });\r\n        }\r\n\r\n        let fields = [];\r\n\r\n        // Sqlite pre 2.2 behavior - Error: SQLITE_CONSTRAINT: columns x, y are not unique\r\n        let match = err.message.match(/columns (.*?) are/);\r\n        if (match !== null && match.length >= 2) {\r\n          fields = match[1].split(', ');\r\n        } else {\r\n\r\n          // Sqlite post 2.2 behavior - Error: SQLITE_CONSTRAINT: UNIQUE constraint failed: table.x, table.y\r\n          match = err.message.match(/UNIQUE constraint failed: (.*)/);\r\n          if (match !== null && match.length >= 2) {\r\n            fields = match[1].split(', ').map(columnWithTable => columnWithTable.split('.')[1]);\r\n          }\r\n        }\r\n\r\n        const errors = [];\r\n        let message = 'Validation error';\r\n\r\n        for (const field of fields) {\r\n          errors.push(new sequelizeErrors.ValidationErrorItem(\r\n            this.getUniqueConstraintErrorMessage(field),\r\n            'unique violation', // sequelizeErrors.ValidationErrorItem.Origins.DB,\r\n            field,\r\n            this.instance && this.instance[field],\r\n            this.instance,\r\n            'not_unique',\r\n          ));\r\n        }\r\n\r\n        if (this.model) {\r\n          _.forOwn(this.model.uniqueKeys, constraint => {\r\n            if (_.isEqual(constraint.fields, fields) && Boolean(constraint.msg)) {\r\n              message = constraint.msg;\r\n\r\n              return false;\r\n            }\r\n          });\r\n        }\r\n\r\n        return new sequelizeErrors.UniqueConstraintError({ message, errors, cause: err, fields, stack: errStack });\r\n      }\r\n\r\n      case 'SQLITE_BUSY':\r\n        return new sequelizeErrors.TimeoutError(err, { stack: errStack });\r\n\r\n      default:\r\n        return new sequelizeErrors.DatabaseError(err, { stack: errStack });\r\n    }\r\n  }\r\n\r\n  async handleShowIndexesQuery(data) {\r\n    // Sqlite returns indexes so the one that was defined last is returned first. Lets reverse that!\r\n    return Promise.all(data.reverse().map(async item => {\r\n      item.fields = [];\r\n      item.primary = false;\r\n      item.unique = Boolean(item.unique);\r\n      item.constraintName = item.name;\r\n      const columns = await this.run(`PRAGMA INDEX_INFO(\\`${item.name}\\`)`);\r\n      for (const column of columns) {\r\n        item.fields[column.seqno] = {\r\n          attribute: column.name,\r\n          length: undefined,\r\n          order: undefined,\r\n        };\r\n      }\r\n\r\n      return item;\r\n    }));\r\n  }\r\n\r\n  getDatabaseMethod() {\r\n    if (this.isInsertQuery() || this.isUpdateQuery() || this.isUpsertQuery() || this.isBulkUpdateQuery() || this.sql.toLowerCase().includes('CREATE TEMPORARY TABLE'.toLowerCase()) || this.options.type === QueryTypes.BULKDELETE) {\r\n      return 'run';\r\n    }\r\n\r\n    return 'all';\r\n  }\r\n}\r\n"],
  "mappings": "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",
  "names": []
}
