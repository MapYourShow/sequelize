{
  "version": 3,
  "sources": ["../src/transaction.ts"],
  "sourcesContent": ["import assert from 'assert';\r\nimport type { Logging, Sequelize, Deferrable, PartlyRequired, Connection } from './index.js';\r\n\r\ntype AfterTransactionCommitCallback = (transaction: Transaction) => void | Promise<void>;\r\n\r\n/**\r\n * The transaction object is used to identify a running transaction.\r\n * It is created by calling `Sequelize.transaction()`.\r\n * To run a query under a transaction, you should pass the transaction in the options object.\r\n *\r\n * @class Transaction\r\n * @see {Sequelize.transaction}\r\n */\r\nexport class Transaction {\r\n\r\n  sequelize: Sequelize;\r\n\r\n  private readonly _afterCommitHooks: Set<AfterTransactionCommitCallback> = new Set();\r\n  private readonly savepoints: Transaction[] = [];\r\n  private readonly options: PartlyRequired<TransactionOptions, 'type' | 'isolationLevel' | 'readOnly'>;\r\n  private readonly parent: Transaction | null;\r\n  private readonly id: string;\r\n  private readonly name: string;\r\n  private finished: 'commit' | undefined;\r\n  private connection: Connection | undefined;\r\n\r\n  /**\r\n   * Creates a new transaction instance\r\n   *\r\n   * @param sequelize A configured sequelize Instance\r\n   * @param options An object with options\r\n   * @param [options.type] Sets the type of the transaction. Sqlite only\r\n   * @param [options.isolationLevel] Sets the isolation level of the transaction.\r\n   * @param [options.deferrable] Sets the constraints to be deferred or immediately checked. PostgreSQL only\r\n   */\r\n  constructor(sequelize: Sequelize, options: TransactionOptions) {\r\n    this.sequelize = sequelize;\r\n\r\n    // get dialect specific transaction options\r\n    const generateTransactionId = this.sequelize.dialect\r\n      .queryGenerator\r\n      .generateTransactionId;\r\n\r\n    this.options = {\r\n      type: sequelize.options.transactionType,\r\n      isolationLevel: sequelize.options.isolationLevel,\r\n      readOnly: false,\r\n      ...options,\r\n    };\r\n\r\n    this.parent = this.options.transaction ?? null;\r\n\r\n    if (this.parent) {\r\n      this.id = this.parent.id;\r\n      this.parent.savepoints.push(this);\r\n      this.name = `${this.id}-sp-${this.parent.savepoints.length}`;\r\n    } else {\r\n      const id = generateTransactionId();\r\n      this.id = id;\r\n      this.name = id;\r\n    }\r\n\r\n    delete this.options.transaction;\r\n  }\r\n\r\n  /**\r\n   * Commit the transaction.\r\n   */\r\n  async commit(): Promise<void> {\r\n    if (this.finished) {\r\n      throw new Error(`Transaction cannot be committed because it has been finished with state: ${this.finished}`);\r\n    }\r\n\r\n    try {\r\n      return await this.sequelize.getQueryInterface().commitTransaction(this, this.options);\r\n    } finally {\r\n      this.finished = 'commit';\r\n      await this.cleanup();\r\n      for (const hook of this._afterCommitHooks) {\r\n        // eslint-disable-next-line no-await-in-loop -- sequentially call hooks\r\n        await Reflect.apply(hook, this, [this]);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Rollback (abort) the transaction\r\n   */\r\n  async rollback(): Promise<void> {\r\n    if (this.finished) {\r\n      throw new Error(`Transaction cannot be rolled back because it has been finished with state: ${this.finished}`);\r\n    }\r\n\r\n    if (!this.connection) {\r\n      throw new Error('Transaction cannot be rolled back because it never started');\r\n    }\r\n\r\n    try {\r\n      return await this\r\n        .sequelize\r\n        .getQueryInterface()\r\n        .rollbackTransaction(this, this.options);\r\n    } finally {\r\n      await this.cleanup();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Called to acquire a connection to use and set the correct options on the connection.\r\n   * We should ensure all of the environment that's set up is cleaned up in `cleanup()` below.\r\n   *\r\n   * @param useCLS Defaults to true: Use CLS (Continuation Local Storage) with Sequelize. With CLS, all queries within the transaction callback will automatically receive the transaction object.\r\n   */\r\n  async prepareEnvironment(useCLS?: boolean) {\r\n    if (useCLS === undefined) {\r\n      useCLS = true;\r\n    }\r\n\r\n    let connection;\r\n    if (this.parent) {\r\n      connection = this.parent.connection;\r\n    } else {\r\n      connection = await this.sequelize.connectionManager.getConnection({\r\n        type: this.options.readOnly ? 'read' : 'write',\r\n        uuid: this.id,\r\n      });\r\n    }\r\n\r\n    assert(connection != null, 'Transaction failed to acquire Connection.');\r\n\r\n    connection.uuid = this.id;\r\n\r\n    this.connection = connection;\r\n\r\n    let result;\r\n    try {\r\n      await this.begin();\r\n      result = await this.setDeferrable();\r\n    } catch (error) {\r\n      try {\r\n        result = await this.rollback();\r\n      } finally {\r\n        throw error; // eslint-disable-line no-unsafe-finally -- while this will mask the error thrown by `rollback`, the previous error is more important.\r\n      }\r\n    }\r\n\r\n    if (useCLS && this.sequelize.Sequelize._cls) {\r\n      this.sequelize.Sequelize._cls.set('transaction', this);\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  async setDeferrable(): Promise<void> {\r\n    if (this.options.deferrable) {\r\n      await this\r\n        .sequelize\r\n        .getQueryInterface()\r\n        .deferConstraints(this, this.options);\r\n    }\r\n  }\r\n\r\n  async begin() {\r\n    const queryInterface = this.sequelize.getQueryInterface();\r\n\r\n    if (this.sequelize.dialect.supports.settingIsolationLevelDuringTransaction) {\r\n      await queryInterface.startTransaction(this, this.options);\r\n\r\n      return queryInterface.setIsolationLevel(this, this.options.isolationLevel, this.options);\r\n    }\r\n\r\n    await queryInterface.setIsolationLevel(this, this.options.isolationLevel, this.options);\r\n\r\n    return queryInterface.startTransaction(this, this.options);\r\n  }\r\n\r\n  async cleanup(): Promise<void> {\r\n    // Don't release the connection if there's a parent transaction or\r\n    // if we've already cleaned up\r\n    if (this.parent || this.connection?.uuid === undefined) {\r\n      return;\r\n    }\r\n\r\n    this._clearCls();\r\n    const res = this.sequelize.connectionManager.releaseConnection(this.connection);\r\n    this.connection.uuid = undefined;\r\n\r\n    await res;\r\n  }\r\n\r\n  _clearCls() {\r\n    const cls = this.sequelize.Sequelize._cls;\r\n\r\n    if (cls && cls.get('transaction') === this) {\r\n      cls.set('transaction', null);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Adds a hook that is run after a transaction is committed.\r\n   *\r\n   * @param fn   A callback function that is called with the committed transaction\r\n   * @name afterCommit\r\n   * @memberof Sequelize.Transaction\r\n   */\r\n  afterCommit(fn: AfterTransactionCommitCallback): this {\r\n    if (typeof fn !== 'function') {\r\n      throw new TypeError('\"fn\" must be a function');\r\n    }\r\n\r\n    this._afterCommitHooks.add(fn);\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Types can be set per-transaction by passing `options.type` to `sequelize.transaction`.\r\n   * Default to `DEFERRED` but you can override the default type by passing `options.transactionType` in `new Sequelize`.\r\n   * Sqlite only.\r\n   *\r\n   * Pass in the desired level as the first argument:\r\n   *\r\n   * @example\r\n   * try {\r\n   *   await sequelize.transaction({ type: Sequelize.Transaction.TYPES.EXCLUSIVE }, transaction => {\r\n   *      // your transactions\r\n   *   });\r\n   *   // transaction has been committed. Do something after the commit if required.\r\n   * } catch(err) {\r\n   *   // do something with the err.\r\n   * }\r\n   *\r\n   * @property DEFERRED\r\n   * @property IMMEDIATE\r\n   * @property EXCLUSIVE\r\n   */\r\n  static get TYPES() {\r\n    return TRANSACTION_TYPES;\r\n  }\r\n\r\n  /**\r\n   * Isolation levels can be set per-transaction by passing `options.isolationLevel` to `sequelize.transaction`.\r\n   * Sequelize uses the default isolation level of the database, you can override this by passing `options.isolationLevel` in Sequelize constructor options.\r\n   *\r\n   * Pass in the desired level as the first argument:\r\n   *\r\n   * @example\r\n   * try {\r\n   *   const result = await sequelize.transaction({isolationLevel: Sequelize.Transaction.ISOLATION_LEVELS.SERIALIZABLE}, transaction => {\r\n   *     // your transactions\r\n   *   });\r\n   *   // transaction has been committed. Do something after the commit if required.\r\n   * } catch(err) {\r\n   *   // do something with the err.\r\n   * }\r\n   *\r\n   * @property READ_UNCOMMITTED\r\n   * @property READ_COMMITTED\r\n   * @property REPEATABLE_READ\r\n   * @property SERIALIZABLE\r\n   */\r\n  static get ISOLATION_LEVELS() {\r\n    return ISOLATION_LEVELS;\r\n  }\r\n\r\n  /**\r\n   * Possible options for row locking. Used in conjunction with `find` calls:\r\n   *\r\n   * @example\r\n   * // t1 is a transaction\r\n   * Model.findAll({\r\n   *   where: ...,\r\n   *   transaction: t1,\r\n   *   lock: t1.LOCK...\r\n   * });\r\n   *\r\n   * @example <caption>Postgres also supports specific locks while eager loading by using OF:</caption>\r\n   * UserModel.findAll({\r\n   *   where: ...,\r\n   *   include: [TaskModel, ...],\r\n   *   transaction: t1,\r\n   *   lock: {\r\n   *     level: t1.LOCK...,\r\n   *     of: UserModel\r\n   *   }\r\n   * });\r\n   *\r\n   * # UserModel will be locked but TaskModel won't!\r\n   *\r\n   * @example <caption>You can also skip locked rows:</caption>\r\n   * // t1 is a transaction\r\n   * Model.findAll({\r\n   *   where: ...,\r\n   *   transaction: t1,\r\n   *   lock: true,\r\n   *   skipLocked: true\r\n   * });\r\n   * # The query will now return any rows that aren't locked by another transaction\r\n   *\r\n   * @returns possible options for row locking\r\n   * @property UPDATE\r\n   * @property SHARE\r\n   * @property KEY_SHARE Postgres 9.3+ only\r\n   * @property NO_KEY_UPDATE Postgres 9.3+ only\r\n   */\r\n  static get LOCK() {\r\n    return LOCK;\r\n  }\r\n\r\n  /**\r\n   * Same as {@link Transaction.LOCK}, but can also be called on instances of\r\n   * transactions to get possible options for row locking directly from the\r\n   * instance.\r\n   */\r\n  get LOCK() {\r\n    return LOCK;\r\n  }\r\n}\r\n\r\n/**\r\n * Isolations levels can be set per-transaction by passing `options.isolationLevel` to `sequelize.transaction`.\r\n * Default to `REPEATABLE_READ` but you can override the default isolation level by passing `options.isolationLevel` in `new Sequelize`.\r\n *\r\n * The possible isolations levels to use when starting a transaction:\r\n *\r\n * ```js\r\n * {\r\n *   READ_UNCOMMITTED: \"READ UNCOMMITTED\",\r\n *   READ_COMMITTED: \"READ COMMITTED\",\r\n *   REPEATABLE_READ: \"REPEATABLE READ\",\r\n *   SERIALIZABLE: \"SERIALIZABLE\"\r\n * }\r\n * ```\r\n *\r\n * Pass in the desired level as the first argument:\r\n *\r\n * ```js\r\n * try {\r\n *   await sequelize.transaction({isolationLevel: Sequelize.Transaction.SERIALIZABLE}, transaction => {\r\n *      // your transactions\r\n *   });\r\n *   // transaction has been committed. Do something after the commit if required.\r\n * } catch(err) {\r\n *   // do something with the err.\r\n * }\r\n * ```\r\n */\r\nexport enum ISOLATION_LEVELS {\r\n  READ_UNCOMMITTED = 'READ UNCOMMITTED',\r\n  READ_COMMITTED = 'READ COMMITTED',\r\n  REPEATABLE_READ = 'REPEATABLE READ',\r\n  SERIALIZABLE = 'SERIALIZABLE',\r\n}\r\n\r\nexport enum TRANSACTION_TYPES {\r\n  DEFERRED = 'DEFERRED',\r\n  IMMEDIATE = 'IMMEDIATE',\r\n  EXCLUSIVE = 'EXCLUSIVE',\r\n}\r\n\r\n/**\r\n * Possible options for row locking. Used in conjunction with `find` calls:\r\n *\r\n * Usage:\r\n * ```js\r\n * import { LOCK } from '@sequelize/core';\r\n *\r\n * Model.findAll({\r\n *   transaction,\r\n *   lock: LOCK.UPDATE,\r\n * });\r\n * ```\r\n *\r\n * Postgres also supports specific locks while eager loading by using OF:\r\n * ```js\r\n * import { LOCK } from '@sequelize/core';\r\n *\r\n * UserModel.findAll({\r\n *   transaction,\r\n *   lock: {\r\n *     level: LOCK.KEY_SHARE,\r\n *     of: UserModel,\r\n *   },\r\n * });\r\n * ```\r\n * UserModel will be locked but other models won't be!\r\n *\r\n * [Read more on transaction locks here](https://sequelize.org/docs/v7/other-topics/transactions/#locks)\r\n */\r\nexport enum LOCK {\r\n  UPDATE = 'UPDATE',\r\n  SHARE = 'SHARE',\r\n  /**\r\n   * Postgres 9.3+ only\r\n   */\r\n  KEY_SHARE = 'KEY SHARE',\r\n  /**\r\n   * Postgres 9.3+ only\r\n   */\r\n  NO_KEY_UPDATE = 'NO KEY UPDATE',\r\n}\r\n\r\n/**\r\n * Options provided when the transaction is created\r\n */\r\nexport interface TransactionOptions extends Logging {\r\n  readOnly?: boolean;\r\n  autocommit?: boolean;\r\n  isolationLevel?: ISOLATION_LEVELS;\r\n  type?: TRANSACTION_TYPES;\r\n  deferrable?: string | Deferrable;\r\n  /**\r\n   * Parent transaction.\r\n   */\r\n  transaction?: Transaction | null;\r\n}\r\n"],
  "mappings": "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",
  "names": []
}
