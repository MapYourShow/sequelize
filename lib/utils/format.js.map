{
  "version": 3,
  "sources": ["../../src/utils/format.ts"],
  "sourcesContent": ["import assert from 'assert';\r\nimport forIn from 'lodash/forIn';\r\nimport isPlainObject from 'lodash/isPlainObject';\r\nimport type {\r\n  Model,\r\n  ModelStatic,\r\n  WhereOptions,\r\n  ModelAttributeColumnOptions,\r\n  Attributes,\r\n  BuiltModelAttributeColumOptions,\r\n} from '..';\r\n// eslint-disable-next-line import/order -- caused by temporarily mixing require with import\r\nimport { Op as operators } from '../operators';\r\n\r\nconst DataTypes = require('../data-types');\r\n\r\nconst operatorsSet = new Set(Object.values(operators));\r\n\r\nexport type FinderOptions<TAttributes> = {\r\n  attributes?: string[],\r\n  where?: WhereOptions<TAttributes>,\r\n};\r\n\r\nexport type MappedFinderOptions<TAttributes> = Omit<FinderOptions<TAttributes>, 'attributes'> & {\r\n  // an array of attribute-column mapping, or just attributes\r\n  attributes?: Array<[columnName: string, attributeName: string] | string>,\r\n};\r\n\r\n/**\r\n * Expand and normalize finder options.\r\n * Mutates the \"options\" parameter.\r\n *\r\n * @param options\r\n * @param Model\r\n */\r\nexport function mapFinderOptions<M extends Model, T extends FinderOptions<Attributes<M>>>(\r\n  options: T,\r\n  Model: ModelStatic<Model>,\r\n): MappedFinderOptions<Attributes<M>> {\r\n  if (Array.isArray(options.attributes)) {\r\n    options.attributes = Model._injectDependentVirtualAttributes(\r\n      options.attributes,\r\n    );\r\n\r\n    options.attributes = options.attributes.filter(\r\n      v => !Model._virtualAttributes.has(v),\r\n    );\r\n  }\r\n\r\n  mapOptionFieldNames(options, Model);\r\n\r\n  return options;\r\n}\r\n\r\n/**\r\n * Used to map field names in attributes and where conditions.\r\n *\r\n * Mutates the \"options\" parameter.\r\n *\r\n * @param options\r\n * @param Model\r\n */\r\nexport function mapOptionFieldNames<M extends Model>(\r\n  options: FinderOptions<Attributes<M>>,\r\n  Model: ModelStatic<Model>,\r\n): MappedFinderOptions<Attributes<M>> {\r\n\r\n  // note: parts of Sequelize rely on this function mutating its inputs.\r\n  //  be aware that these places need to be fixed before trying to make this a pure function.\r\n  //  - ephys\r\n\r\n  const out: MappedFinderOptions<Attributes<M>> = options;\r\n\r\n  if (Array.isArray(options.attributes)) {\r\n    out.attributes = options.attributes.map(attributeName => {\r\n      // Object lookups will force any variable to strings, we don't want that for special objects etc\r\n      if (typeof attributeName !== 'string') {\r\n        return attributeName;\r\n      }\r\n\r\n      // Map attributes to column names\r\n      const columnName: string | undefined = Model.rawAttributes[attributeName]?.field;\r\n      if (columnName && columnName !== attributeName) {\r\n        return [columnName, attributeName];\r\n      }\r\n\r\n      return attributeName;\r\n    });\r\n  }\r\n\r\n  if (options.where != null && isPlainObject(options.where)) {\r\n    // eslint-disable-next-line @typescript-eslint/prefer-ts-expect-error -- this fails in TS 4.4 and up, but not before\r\n    // @ts-ignore the work necessary to type the return type of mapWhereFieldNames is not worth it\r\n    out.where = mapWhereFieldNames(options.where, Model);\r\n  }\r\n\r\n  return out;\r\n}\r\n\r\nexport function mapWhereFieldNames(where: Record<string | symbol, any>, Model: ModelStatic<Model>): object {\r\n  if (!where) {\r\n    return where;\r\n  }\r\n\r\n  const newWhere: Record<string | symbol, any> = Object.create(null);\r\n  // TODO [2022-09-01]: note on 'as any[]': TypeScript < 4.4 does not support using Symbol for keys.\r\n  //  Cast can be removed in sept. 2022 when we drop support for < 4.4\r\n  for (const attributeNameOrOperator of getComplexKeys(where) as any[]) {\r\n    const rawAttribute: ModelAttributeColumnOptions | undefined = Model.rawAttributes[attributeNameOrOperator];\r\n\r\n    // TODO [2022-09-01]: note on 'any': TypeScript < 4.4 does not support using Symbol for keys.\r\n    //  Cast can changed back to 'symbol | string' in sept. 2022 when we drop support for < 4.4\r\n    const columnNameOrOperator: any = rawAttribute?.field ?? attributeNameOrOperator;\r\n\r\n    if (\r\n      isPlainObject(where[attributeNameOrOperator])\r\n        && !(\r\n          rawAttribute\r\n          && (rawAttribute.type instanceof DataTypes.HSTORE\r\n            || rawAttribute.type instanceof DataTypes.JSON)\r\n        )\r\n    ) {\r\n      // Prevent renaming of HSTORE & JSON fields\r\n      newWhere[columnNameOrOperator] = mapOptionFieldNames(\r\n        {\r\n          where: where[attributeNameOrOperator],\r\n        },\r\n        Model,\r\n      ).where;\r\n\r\n      continue;\r\n    }\r\n\r\n    if (Array.isArray(where[attributeNameOrOperator])) {\r\n      newWhere[columnNameOrOperator] = [...where[attributeNameOrOperator]];\r\n\r\n      for (const [index, wherePart] of where[attributeNameOrOperator].entries()) {\r\n        if (isPlainObject(wherePart)) {\r\n          newWhere[columnNameOrOperator][index] = mapWhereFieldNames(wherePart, Model);\r\n        }\r\n      }\r\n\r\n      continue;\r\n    }\r\n\r\n    newWhere[columnNameOrOperator] = where[attributeNameOrOperator];\r\n  }\r\n\r\n  return newWhere;\r\n}\r\n\r\n/**\r\n * getComplexKeys\r\n *\r\n * @param obj\r\n * @returns All keys including operators\r\n * @private\r\n */\r\nexport function getComplexKeys(obj: object): Array<string | symbol> {\r\n  return [\r\n    ...getOperators(obj),\r\n    ...Object.keys(obj),\r\n  ];\r\n}\r\n\r\n/**\r\n * getOperators\r\n *\r\n * @param obj\r\n * @returns All operators properties of obj\r\n * @private\r\n */\r\nexport function getOperators(obj: object): symbol[] {\r\n  return Object.getOwnPropertySymbols(obj).filter(s => operatorsSet.has(s));\r\n}\r\n\r\nexport function combineTableNames(tableName1: string, tableName2: string): string {\r\n  return tableName1.toLowerCase() < tableName2.toLowerCase()\r\n    ? tableName1 + tableName2\r\n    : tableName2 + tableName1;\r\n}\r\n\r\n/**\r\n * Used to map field names in values\r\n *\r\n * @param dataValues\r\n * @param attributeNames\r\n * @param ModelClass\r\n */\r\nexport function mapValueFieldNames( // TODO: rename to mapAttributesToColumNames? See https://github.com/sequelize/meetings/issues/17\r\n  dataValues: Record<string, any>,\r\n  attributeNames: string[],\r\n  ModelClass: ModelStatic<Model>,\r\n): Record<string, any> {\r\n  const values: Record<string, any> = Object.create(null);\r\n\r\n  for (const attributeName of attributeNames) {\r\n    if (dataValues[attributeName] !== undefined && !ModelClass._virtualAttributes.has(attributeName)) {\r\n      // Field name mapping\r\n      const columnName = ModelClass.rawAttributes[attributeName]?.field ?? attributeName;\r\n\r\n      values[columnName] = dataValues[attributeName];\r\n    }\r\n  }\r\n\r\n  return values;\r\n}\r\n\r\n/**\r\n * Removes entries from `hash` whose value is either null or undefined, unless `omitNull` is false or `allowNull` includes that key.\r\n *\r\n * Keys ending with 'Id' are never removed.\r\n *\r\n * @param hash the object from which entries with nullish values will be removed.\r\n * @param omitNull if false, this method returns the object as-is\r\n * @param options\r\n * @param options.allowNull A list of keys that must be preserved even if their value is null or undefined.\r\n */\r\nexport function removeNullishValuesFromHash(\r\n  hash: Record<string, any>,\r\n  omitNull: boolean,\r\n  options?: { allowNull?: string[] },\r\n): Record<string, any> {\r\n  let result = hash;\r\n\r\n  const allowNull = options?.allowNull ?? [];\r\n\r\n  if (!omitNull) {\r\n    return result;\r\n  }\r\n\r\n  const _hash: { [key: string]: any } = Object.create(null);\r\n\r\n  forIn(hash, (val: any, key: string) => {\r\n    if (\r\n      allowNull.includes(key)\r\n        || key.endsWith('Id')\r\n        || val !== null && val !== undefined\r\n    ) {\r\n      _hash[key] = val;\r\n    }\r\n  });\r\n\r\n  result = _hash;\r\n\r\n  return result;\r\n}\r\n\r\n/**\r\n * Returns ENUM name by joining table and column name\r\n *\r\n * @param tableName\r\n * @param columnName\r\n * @private\r\n */\r\nexport function generateEnumName(\r\n  tableName: string,\r\n  columnName: string,\r\n): string {\r\n  return `enum_${tableName}_${columnName}`;\r\n}\r\n\r\nexport function getColumnName(attribute: BuiltModelAttributeColumOptions): string {\r\n  assert(attribute.fieldName != null, 'getColumnName expects a normalized attribute meta');\r\n\r\n  // field is the column name alias\r\n  // if no alias is set, fieldName (the JS name) will be used instead.\r\n  return attribute.field || attribute.fieldName;\r\n}\r\n"],
  "mappings": "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",
  "names": []
}
