{
  "version": 3,
  "sources": ["../../src/utils/object.ts"],
  "sourcesContent": ["import cloneDeepWith from 'lodash/cloneDeepWith';\r\nimport forOwn from 'lodash/forOwn';\r\nimport getValue from 'lodash/get';\r\nimport isEqual from 'lodash/isEqual';\r\nimport isFunction from 'lodash/isFunction';\r\nimport isPlainObject from 'lodash/isPlainObject';\r\nimport mergeWith from 'lodash/mergeWith';\r\nimport { getComplexKeys } from './format';\r\n// eslint-disable-next-line import/order -- caused by temporarily mixing require with import\r\nimport { camelize } from './string';\r\n\r\nconst baseIsNative = require('lodash/_baseIsNative');\r\n\r\n/**\r\n * Deeply merges object `b` into `a`.\r\n * Mutates `a`.\r\n *\r\n * Same concept as _.merge, but doesn't overwrite properties that have already been assigned.\r\n *\r\n * @param a\r\n * @param b\r\n */\r\nexport function mergeDefaults<T>(a: T, b: Partial<T>): T {\r\n  return mergeWith(a, b, (objectValue, sourceValue) => {\r\n    // If it's an object, let _ handle it this time, we will be called again for each property\r\n    if (!isPlainObject(objectValue) && objectValue !== undefined) {\r\n      // _.isNative includes a check for core-js and throws an error if present.\r\n      // Depending on _baseIsNative bypasses the core-js check.\r\n      if (isFunction(objectValue) && baseIsNative(objectValue)) {\r\n        return sourceValue || objectValue;\r\n      }\r\n\r\n      return objectValue;\r\n    }\r\n\r\n    // eslint-disable-next-line consistent-return,no-useless-return -- lodash actually wants us to return `undefined` to fallback to the default customizer.\r\n    return;\r\n  });\r\n}\r\n\r\n/**\r\n * An alternative to _.merge, which doesn't clone its arguments.\r\n *\r\n * Does not mutate parameters.\r\n *\r\n * Cloning is a bad idea because options arguments may contain references to sequelize\r\n * models - which again reference database libs which don't like to be cloned (in particular pg-native)\r\n *\r\n * @param args\r\n */\r\nexport function merge(...args: object[]): object {\r\n  const result: { [key: string]: any } = Object.create(null);\r\n\r\n  for (const obj of args) {\r\n    forOwn(obj, (value, key) => {\r\n      if (value === undefined) {\r\n        return;\r\n      }\r\n\r\n      if (!result[key]) {\r\n        result[key] = value;\r\n      } else if (isPlainObject(value) && isPlainObject(result[key])) {\r\n        result[key] = merge(result[key], value);\r\n      } else if (Array.isArray(value) && Array.isArray(result[key])) {\r\n        result[key] = [...value, ...result[key]];\r\n      } else {\r\n        result[key] = value;\r\n      }\r\n    });\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\n/* eslint-disable consistent-return -- lodash actually wants us to return `undefined` to fallback to the default customizer. */\r\nexport function cloneDeep<T extends object>(obj: T, onlyPlain?: boolean): T {\r\n  return cloneDeepWith(obj || {}, elem => {\r\n    // Do not try to customize cloning of arrays or POJOs\r\n    if (Array.isArray(elem) || isPlainObject(elem)) {\r\n      return;\r\n    }\r\n\r\n    // If we specified to clone only plain objects & arrays, we ignore everyhing else\r\n    // In any case, don't clone stuff that's an object, but not a plain one - fx example sequelize models and instances\r\n    if (onlyPlain || typeof elem === 'object') {\r\n      return elem;\r\n    }\r\n\r\n    // Preserve special data-types like `fn` across clones. _.get() is used for checking up the prototype chain\r\n    if (elem && typeof elem.clone === 'function') {\r\n      return elem.clone();\r\n    }\r\n  });\r\n}\r\n/* eslint-enable consistent-return */\r\n\r\n/**\r\n * Receives a tree-like object and returns a plain object which depth is 1.\r\n *\r\n * - Input:\r\n *\r\n *  {\r\n *    name: 'John',\r\n *    address: {\r\n *      street: 'Fake St. 123',\r\n *      coordinates: {\r\n *        longitude: 55.6779627,\r\n *        latitude: 12.5964313\r\n *      }\r\n *    }\r\n *  }\r\n *\r\n * - Output:\r\n *\r\n *  {\r\n *    name: 'John',\r\n *    address.street: 'Fake St. 123',\r\n *    address.coordinates.latitude: 55.6779627,\r\n *    address.coordinates.longitude: 12.5964313\r\n *  }\r\n *\r\n * @param value an Object\r\n * @returns a flattened object\r\n * @private\r\n */\r\nexport function flattenObjectDeep<T>(value: T): T extends object ? Flatten<T> : T {\r\n  if (!isPlainObject(value)) {\r\n    // TypeScript doesn't know T is an object due to isPlainObject's typings. Cast to any.\r\n    return value as any;\r\n  }\r\n\r\n  const flattenedObj: { [key: string]: any } = Object.create(null);\r\n\r\n  function flattenObject(obj: { [key: string]: any }, subPath?: string) {\r\n    for (const key of Object.keys(obj)) {\r\n      const pathToProperty = subPath ? `${subPath}.${key}` : key;\r\n      if (typeof obj[key] === 'object' && obj[key] !== null) {\r\n        flattenObject(obj[key], pathToProperty);\r\n      } else {\r\n        flattenedObj[pathToProperty] = getValue(obj, key);\r\n      }\r\n    }\r\n\r\n    return flattenedObj;\r\n  }\r\n\r\n  return flattenObject(value) as any;\r\n}\r\n\r\n// taken from\r\n// https://stackoverflow.com/questions/66614528/flatten-object-with-custom-keys-in-typescript\r\n// because this is typescript black magic\r\ntype Flatten<T extends object> = object extends T ? object : {\r\n  [K in keyof T]-?: (x: NonNullable<T[K]> extends infer V ? V extends object ?\r\n    V extends readonly any[] ? Pick<T, K> : Flatten<V> extends infer FV ? ({\r\n      [P in keyof FV as `${Extract<K, string | number>}.${Extract<P, string | number>}`]:\r\n      FV[P] }) : never : Pick<T, K> : never\r\n  ) => void } extends Record<keyof T, (y: infer O) => void> ?\r\n  O extends unknown ? { [K in keyof O]: O[K] } : never : never;\r\n\r\n/**\r\n * Assigns own and inherited enumerable string and symbol keyed properties of source\r\n * objects to the destination object.\r\n *\r\n * https://lodash.com/docs/4.17.4#defaults\r\n *\r\n * **Note:** This method mutates `object`.\r\n *\r\n * @param objectIn The destination object.\r\n * @param sources The source objects.\r\n * @returns Returns `object`.\r\n * @private\r\n */\r\nexport function defaults(\r\n  objectIn: { [key: string]: any }, // TODO [2022-09-01]: key should be string | symbol once we drop support for TS 4.4\r\n  ...sources: Array<{ [key: string]: any }> // TODO [2022-09-01]: key should be string | symbol once we drop support for TS 4.4\r\n): object {\r\n  for (const source of sources) {\r\n    if (!source) {\r\n      continue;\r\n    }\r\n\r\n    // TODO [2022-09-01]: note on 'as any[]': TypeScript < 4.4 does not support using Symbol for keys.\r\n    //  Cast can be removed in sept. 2022 when we drop support for < 4.4\r\n    for (const key of getComplexKeys(source) as any[]) {\r\n      const value = objectIn[key];\r\n      const objectPrototype: { [key: string]: any } = Object.prototype; // TODO [2022-09-01]: key should be string | symbol once we drop support for TS 4.4\r\n\r\n      if (\r\n        value === undefined\r\n        || isEqual(value, objectPrototype[key])\r\n        && !Object.prototype.hasOwnProperty.call(objectIn, key)\r\n      ) {\r\n        objectIn[key] = source[key];\r\n      }\r\n    }\r\n  }\r\n\r\n  return objectIn;\r\n}\r\n\r\n/**\r\n * @param obj\r\n * @returns A new object with camel-cased keys\r\n * @private\r\n */\r\nexport function camelizeObjectKeys(obj: { [key: string]: any }) {\r\n  const newObj: { [key: string]: any } = Object.create(null);\r\n\r\n  for (const key of Object.keys(obj)) {\r\n    newObj[camelize(key)] = obj[key];\r\n  }\r\n\r\n  return newObj;\r\n}\r\n"],
  "mappings": "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",
  "names": []
}
