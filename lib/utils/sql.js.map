{
  "version": 3,
  "sources": ["../../src/utils/sql.ts"],
  "sourcesContent": ["import isPlainObject from 'lodash/isPlainObject';\r\nimport type { AbstractDialect, BindCollector } from '../dialects/abstract/index.js';\r\nimport type { BindOrReplacements } from '../sequelize.js';\r\nimport { escape as escapeSqlValue } from '../sql-string';\r\n\r\ntype OnBind = (oldName: string) => string;\r\n\r\ntype MapSqlOptions = {\r\n  onPositionalReplacement?(): void,\r\n};\r\n\r\n/**\r\n * Internal function used by {@link mapBindParameters} and {@link injectReplacements}.\r\n * Parse bind parameters & replacements in places where they would be valid SQL values.\r\n *\r\n * @param sqlString The SQL that contains the bind parameters & replacements\r\n * @param dialect The dialect of the SQL\r\n * @param replacements if provided, this method will replace ':named' replacements & positional replacements (?)\r\n * @param onBind if provided, sequelize will call this method each time a $bind parameter is found, and replace it with its output.\r\n * @param options Options\r\n *\r\n * @returns The SQL with bind parameters & replacements rewritten in their dialect-specific syntax.\r\n */\r\nfunction mapBindParametersAndReplacements(\r\n  sqlString: string,\r\n  dialect: AbstractDialect,\r\n  replacements?: BindOrReplacements,\r\n  onBind?: OnBind,\r\n  options?: MapSqlOptions,\r\n): string {\r\n  const isNamedReplacements = isPlainObject(replacements);\r\n  const isPositionalReplacements = Array.isArray(replacements);\r\n  let lastConsumedPositionalReplacementIndex = -1;\r\n\r\n  let output: string = '';\r\n\r\n  let currentDollarStringTagName = null;\r\n  let isString = false;\r\n  let isColumn = false;\r\n  let previousSliceEnd = 0;\r\n  let isSingleLineComment = false;\r\n  let isCommentBlock = false;\r\n\r\n  for (let i = 0; i < sqlString.length; i++) {\r\n    const char = sqlString[i];\r\n\r\n    if (isColumn) {\r\n      if (char === dialect.TICK_CHAR_RIGHT) {\r\n        isColumn = false;\r\n      }\r\n\r\n      continue;\r\n    }\r\n\r\n    if (isString) {\r\n      if (char === `'` && !isBackslashEscaped(sqlString, i - 1)) {\r\n        isString = false;\r\n      }\r\n\r\n      continue;\r\n    }\r\n\r\n    if (currentDollarStringTagName !== null) {\r\n      if (char !== '$') {\r\n        continue;\r\n      }\r\n\r\n      const remainingString = sqlString.slice(i, sqlString.length);\r\n\r\n      const dollarStringStartMatch = remainingString.match(/^\\$(?<name>[a-z_][0-9a-z_])?(\\$)/i);\r\n      const tagName = dollarStringStartMatch?.groups?.name;\r\n      if (currentDollarStringTagName === tagName) {\r\n        currentDollarStringTagName = null;\r\n      }\r\n\r\n      continue;\r\n    }\r\n\r\n    if (isSingleLineComment) {\r\n      if (char === '\\n') {\r\n        isSingleLineComment = false;\r\n      }\r\n\r\n      continue;\r\n    }\r\n\r\n    if (isCommentBlock) {\r\n      if (char === '*' && sqlString[i + 1] === '/') {\r\n        isCommentBlock = false;\r\n      }\r\n\r\n      continue;\r\n    }\r\n\r\n    if (char === dialect.TICK_CHAR_LEFT) {\r\n      isColumn = true;\r\n      continue;\r\n    }\r\n\r\n    if (char === `'`) {\r\n      isString = true;\r\n      continue;\r\n    }\r\n\r\n    if (char === '-' && sqlString.slice(i, i + 3) === '-- ') {\r\n      isSingleLineComment = true;\r\n      continue;\r\n    }\r\n\r\n    if (char === '/' && sqlString.slice(i, i + 2) === '/*') {\r\n      isCommentBlock = true;\r\n      continue;\r\n    }\r\n\r\n    // either the start of a $bind parameter, or the start of a $tag$string$tag$\r\n    if (char === '$') {\r\n      const previousChar = sqlString[i - 1];\r\n\r\n      // we are part of an identifier\r\n      if (/[0-9a-z_]/i.test(previousChar)) {\r\n        continue;\r\n      }\r\n\r\n      const remainingString = sqlString.slice(i, sqlString.length);\r\n\r\n      const dollarStringStartMatch = remainingString.match(/^\\$(?<name>[a-z_][0-9a-z_]*)?\\$/i);\r\n      if (dollarStringStartMatch) {\r\n        currentDollarStringTagName = dollarStringStartMatch.groups?.name ?? '';\r\n\r\n        continue;\r\n      }\r\n\r\n      if (onBind) {\r\n        // we want to be conservative with what we consider to be a bind parameter to avoid risk of conflict with potential operators\r\n        // users need to add a space before the bind parameter (except after '(', ',', and '=')\r\n        if (previousChar !== undefined && !/[\\s(,=]/.test(previousChar)) {\r\n          continue;\r\n        }\r\n\r\n        // detect the bind param if it's a valid identifier and it's followed either by '::' (=cast), ')', whitespace of it's the end of the query.\r\n        const match = remainingString.match(/^\\$(?<name>([a-z_][0-9a-z_]*|[1-9][0-9]*))(?:\\)|,|$|\\s|::|;)/i);\r\n        const bindParamName = match?.groups?.name;\r\n        if (!bindParamName) {\r\n          continue;\r\n        }\r\n\r\n        // we found a bind parameter\r\n        const newName: string = onBind(bindParamName);\r\n\r\n        // add everything before the bind parameter name\r\n        output += sqlString.slice(previousSliceEnd, i);\r\n        // continue after the bind parameter name\r\n        previousSliceEnd = i + bindParamName.length + 1;\r\n\r\n        output += newName;\r\n      }\r\n\r\n      continue;\r\n    }\r\n\r\n    if (isNamedReplacements && char === ':') {\r\n      const previousChar = sqlString[i - 1];\r\n      // we want to be conservative with what we consider to be a replacement to avoid risk of conflict with potential operators\r\n      // users need to add a space before the bind parameter (except after '(', ',', '=', and '[' (for arrays))\r\n      if (previousChar !== undefined && !/[\\s(,=[]/.test(previousChar)) {\r\n        continue;\r\n      }\r\n\r\n      const remainingString = sqlString.slice(i, sqlString.length);\r\n\r\n      const match = remainingString.match(/^:(?<name>[a-z_][0-9a-z_]*)(?:\\)|,|$|\\s|::|;|])/i);\r\n      const replacementName = match?.groups?.name;\r\n      if (!replacementName) {\r\n        continue;\r\n      }\r\n\r\n      // @ts-expect-error -- isPlainObject does not tell typescript that replacements is a plain object, not an array\r\n      const replacementValue = replacements[replacementName];\r\n      if (!Object.prototype.hasOwnProperty.call(replacements, replacementName) || replacementValue === undefined) {\r\n        throw new Error(`Named replacement \":${replacementName}\" has no entry in the replacement map.`);\r\n      }\r\n\r\n      const escapedReplacement = escapeSqlValue(replacementValue, undefined, dialect.name, true);\r\n\r\n      // add everything before the bind parameter name\r\n      output += sqlString.slice(previousSliceEnd, i);\r\n      // continue after the bind parameter name\r\n      previousSliceEnd = i + replacementName.length + 1;\r\n\r\n      output += escapedReplacement;\r\n\r\n      continue;\r\n    }\r\n\r\n    if (isPositionalReplacements && char === '?') {\r\n      const previousChar = sqlString[i - 1];\r\n\r\n      // we want to be conservative with what we consider to be a replacement to avoid risk of conflict with potential operators\r\n      // users need to add a space before the bind parameter (except after '(', ',', '=', and '[' (for arrays))\r\n      if (previousChar !== undefined && !/[\\s(,=[]/.test(previousChar)) {\r\n        continue;\r\n      }\r\n\r\n      // don't parse ?| and ?& operators as replacements\r\n      const nextChar = sqlString[i + 1];\r\n      if (nextChar === '|' || nextChar === '&') {\r\n        continue;\r\n      }\r\n\r\n      // this is a positional replacement\r\n      if (options?.onPositionalReplacement) {\r\n        options.onPositionalReplacement();\r\n      }\r\n\r\n      const replacementIndex = ++lastConsumedPositionalReplacementIndex;\r\n      const replacementValue = replacements[lastConsumedPositionalReplacementIndex];\r\n\r\n      if (replacementValue === undefined) {\r\n        throw new Error(`Positional replacement (?) ${replacementIndex} has no entry in the replacement map (replacements[${replacementIndex}] is undefined).`);\r\n      }\r\n\r\n      const escapedReplacement = escapeSqlValue(replacementValue as any, undefined, dialect.name, true);\r\n\r\n      // add everything before the bind parameter name\r\n      output += sqlString.slice(previousSliceEnd, i);\r\n      // continue after the bind parameter name\r\n      previousSliceEnd = i + 1;\r\n\r\n      output += escapedReplacement;\r\n    }\r\n  }\r\n\r\n  output += sqlString.slice(previousSliceEnd, sqlString.length);\r\n\r\n  return output;\r\n}\r\n\r\n/**\r\n * Maps bind parameters from Sequelize's format ($1 or $name) to the dialect's format.\r\n *\r\n * @param sqlString\r\n * @param dialect\r\n */\r\nexport function mapBindParameters(sqlString: string, dialect: AbstractDialect): {\r\n  sql: string,\r\n  bindOrder: string[] | null,\r\n  parameterSet: Set<string>,\r\n} {\r\n  const parameterCollector = dialect.createBindCollector();\r\n  const parameterSet = new Set<string>();\r\n\r\n  const newSql = mapBindParametersAndReplacements(sqlString, dialect, undefined, foundBindParamName => {\r\n    parameterSet.add(foundBindParamName);\r\n\r\n    return parameterCollector.collect(foundBindParamName);\r\n  });\r\n\r\n  return { sql: newSql, bindOrder: parameterCollector.getBindParameterOrder(), parameterSet };\r\n}\r\n\r\nexport function injectReplacements(\r\n  sqlString: string,\r\n  dialect: AbstractDialect,\r\n  replacements: BindOrReplacements,\r\n  opts?: MapSqlOptions,\r\n): string {\r\n  if (replacements == null) {\r\n    return sqlString;\r\n  }\r\n\r\n  if (!Array.isArray(replacements) && !isPlainObject(replacements)) {\r\n    throw new TypeError(`\"replacements\" must be an array or a plain object, but received ${JSON.stringify(replacements)} instead.`);\r\n  }\r\n\r\n  return mapBindParametersAndReplacements(sqlString, dialect, replacements, undefined, opts);\r\n}\r\n\r\nfunction isBackslashEscaped(string: string, pos: number): boolean {\r\n  let escaped = false;\r\n  for (let i = pos; i >= 0; i--) {\r\n    const char = string[i];\r\n    if (char !== '\\\\') {\r\n      break;\r\n    }\r\n\r\n    escaped = !escaped;\r\n  }\r\n\r\n  return escaped;\r\n}\r\n\r\n/**\r\n * Collector for dialects that only support ordered parameters, and whose order matter in the SQL query. (e.g. dialects that use the \"?\" token for parameters)\r\n *\r\n * @param token The token to use as the bind parameter (e.g. '?' in mysql).\r\n */\r\nexport function createUnspecifiedOrderedBindCollector(token = '?'): BindCollector {\r\n  const parameterOrder: string[] = [];\r\n\r\n  return {\r\n    collect(bindParameterName) {\r\n      parameterOrder.push(bindParameterName);\r\n\r\n      return token;\r\n    },\r\n    getBindParameterOrder() {\r\n      return parameterOrder;\r\n    },\r\n  };\r\n}\r\n\r\n/**\r\n * Collector for dialects that only support ordered parameters, but whose order does not matter in the SQL query (e.g. dialect that support parameters names like '$1')\r\n *\r\n * Parameter index starts at 1!\r\n *\r\n * @param prefix The prefix to place before the name of the bind parameter (e.g. @ for mssql, $ for sqlite/postgres)\r\n */\r\nexport function createSpecifiedOrderedBindCollector(prefix = '$'): BindCollector {\r\n  const parameterOrder: string[] = [];\r\n\r\n  return {\r\n    collect(bindParameterName) {\r\n      const cachedPosition = parameterOrder.indexOf(bindParameterName);\r\n      if (cachedPosition === -1) {\r\n        parameterOrder.push(bindParameterName);\r\n\r\n        return `${prefix}${parameterOrder.length}`;\r\n      }\r\n\r\n      return `${prefix}${cachedPosition + 1}`;\r\n    },\r\n    getBindParameterOrder() {\r\n      return parameterOrder;\r\n    },\r\n  };\r\n}\r\n\r\n/**\r\n * Collector for dialects that support named bind parameters (e.g. @name, $name, etc)\r\n *\r\n * @param parameterPrefix The prefix to place before the name of the bind parameter (e.g. @ for mssql, $ for sqlite/postgres)\r\n */\r\nexport function createNamedParamBindCollector(parameterPrefix: string): BindCollector {\r\n  return {\r\n    collect(bindParameterName: string) {\r\n      return parameterPrefix + bindParameterName;\r\n    },\r\n    getBindParameterOrder() {\r\n      return null;\r\n    },\r\n  };\r\n}\r\n\r\nexport function assertNoReservedBind(bind: BindOrReplacements): void {\r\n  if (Array.isArray(bind)) {\r\n    return;\r\n  }\r\n\r\n  for (const key of Object.keys(bind)) {\r\n    if (key.startsWith('sequelize_')) {\r\n      throw new Error('Bind parameters cannot start with \"sequelize_\", these bind parameters are reserved by Sequelize.');\r\n    }\r\n  }\r\n}\r\n\r\nexport function combineBinds(bindA: BindOrReplacements, bindB: { [key: string]: unknown }) {\r\n  if (Array.isArray(bindA)) {\r\n    bindA = arrayBindToNamedBind(bindA);\r\n  }\r\n\r\n  return {\r\n    ...bindA,\r\n    ...bindB,\r\n  };\r\n}\r\n\r\nfunction arrayBindToNamedBind(bind: unknown[]): { [key: string]: unknown } {\r\n  const out = Object.create(null);\r\n\r\n  // eslint-disable-next-line unicorn/no-for-loop -- too slow.\r\n  for (let i = 0; i < bind.length; i++) {\r\n    out[i + 1] = bind[i];\r\n  }\r\n\r\n  return out;\r\n}\r\n"],
  "mappings": "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",
  "names": []
}
