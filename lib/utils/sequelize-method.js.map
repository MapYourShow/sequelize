{
  "version": 3,
  "sources": ["../../src/utils/sequelize-method.ts"],
  "sourcesContent": ["import isObject from 'lodash/isObject';\r\nimport type { Op, WhereOperators, WhereLeftOperand, WhereAttributeHash, WhereAttributeHashValue } from '..';\r\n\r\n/**\r\n * Utility functions for representing SQL functions, and columns that should be escaped.\r\n * Please do not use these functions directly, use Sequelize.fn and Sequelize.col instead.\r\n *\r\n * @private\r\n */\r\nexport class SequelizeMethod {}\r\n\r\n/**\r\n * Do not use me directly. Use {@link Sequelize.fn}\r\n */\r\nexport class Fn extends SequelizeMethod {\r\n  private readonly fn: string;\r\n\r\n  // unknown already covers the other two types, but they've been added explicitly to document\r\n  // passing WhereAttributeHash generates a condition inside the function.\r\n  private readonly args: Array<unknown | SequelizeMethod | WhereAttributeHash>;\r\n\r\n  constructor(fn: string, args: Fn['args']) {\r\n    super();\r\n    this.fn = fn;\r\n    this.args = args;\r\n  }\r\n\r\n  clone(): Fn {\r\n    return new Fn(this.fn, this.args);\r\n  }\r\n}\r\n\r\n/**\r\n * Do not use me directly. Use {@link Sequelize.col}\r\n */\r\nexport class Col extends SequelizeMethod {\r\n  private readonly col: string[] | string;\r\n\r\n  constructor(col: string[] | string, ...args: string[]) {\r\n    super();\r\n    // TODO(ephys): this does not look right. First parameter is ignored if a second parameter is provided.\r\n    //  should we change the signature to `constructor(...cols: string[])`\r\n    if (args.length > 0) {\r\n      col = args;\r\n    }\r\n\r\n    this.col = col;\r\n  }\r\n}\r\n\r\n/**\r\n * Do not use me directly. Use {@link Sequelize.cast}\r\n */\r\nexport class Cast extends SequelizeMethod {\r\n  private readonly val: any;\r\n  private readonly type: string;\r\n  private readonly json: boolean;\r\n\r\n  constructor(val: unknown, type: string = '', json: boolean = false) {\r\n    super();\r\n    this.val = val;\r\n    this.type = type.trim();\r\n    this.json = json;\r\n  }\r\n}\r\n\r\n/**\r\n * Do not use me directly. Use {@link Sequelize.literal}\r\n */\r\nexport class Literal extends SequelizeMethod {\r\n  /** this (type-only) brand prevents TypeScript from thinking Cast is assignable to Literal because they share the same shape */\r\n  declare private readonly brand: 'literal';\r\n\r\n  private readonly val: unknown;\r\n\r\n  constructor(val: unknown) {\r\n    super();\r\n    this.val = val;\r\n  }\r\n}\r\n\r\n/**\r\n * Do not use me directly. Use {@link Sequelize.json}\r\n */\r\nexport class Json extends SequelizeMethod {\r\n  private readonly conditions?: { [key: string]: any };\r\n  private readonly path?: string;\r\n  private readonly value?: string | number | boolean | null;\r\n\r\n  constructor(\r\n    conditionsOrPath: { [key: string]: any } | string,\r\n    value?: string | number | boolean | null,\r\n  ) {\r\n    super();\r\n\r\n    if (typeof conditionsOrPath === 'string') {\r\n      this.path = conditionsOrPath;\r\n\r\n      if (value) {\r\n        this.value = value;\r\n      }\r\n    } else if (isObject(conditionsOrPath)) {\r\n      this.conditions = conditionsOrPath;\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Do not use me directly. Use {@link Sequelize.where}\r\n */\r\nexport class Where<Operator extends keyof WhereOperators = typeof Op.eq> extends SequelizeMethod {\r\n  // TODO [=7]: rename to leftOperand after typescript migration\r\n  private readonly attribute: WhereLeftOperand;\r\n  // TODO [=7]: rename to operator after typescript migration\r\n  private readonly comparator: string | Operator;\r\n  // TODO [=7]: rename to rightOperand after typescript migration\r\n  private readonly logic: WhereOperators[Operator] | WhereAttributeHashValue<any> | any;\r\n\r\n  constructor(leftOperand: WhereLeftOperand, operator: Operator, rightOperand: WhereOperators[Operator]);\r\n  constructor(leftOperand: WhereLeftOperand, operator: string, rightOperand: any);\r\n  constructor(leftOperand: WhereLeftOperand, rightOperand: WhereAttributeHashValue<any>);\r\n  constructor(\r\n    leftOperand: WhereLeftOperand,\r\n    operatorOrRightOperand: string | Operator | WhereAttributeHashValue<any>,\r\n    rightOperand?: WhereOperators[Operator] | any,\r\n  ) {\r\n    super();\r\n\r\n    this.attribute = leftOperand;\r\n\r\n    if (rightOperand !== undefined) {\r\n      this.logic = rightOperand;\r\n      this.comparator = operatorOrRightOperand;\r\n    } else {\r\n      this.logic = operatorOrRightOperand;\r\n      this.comparator = '=';\r\n    }\r\n  }\r\n}\r\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,sBAAqB;AASd,MAAM,gBAAgB;AAAC;AAKvB,MAAM,WAAW,gBAAgB;AAAA,EACrB;AAAA,EAIA;AAAA,EAEjB,YAAY,IAAY,MAAkB;AACxC,UAAM;AACN,SAAK,KAAK;AACV,SAAK,OAAO;AAAA,EACd;AAAA,EAEA,QAAY;AACV,WAAO,IAAI,GAAG,KAAK,IAAI,KAAK,IAAI;AAAA,EAClC;AACF;AAKO,MAAM,YAAY,gBAAgB;AAAA,EACtB;AAAA,EAEjB,YAAY,QAA2B,MAAgB;AACrD,UAAM;AAGN,QAAI,KAAK,SAAS,GAAG;AACnB,YAAM;AAAA,IACR;AAEA,SAAK,MAAM;AAAA,EACb;AACF;AAKO,MAAM,aAAa,gBAAgB;AAAA,EACvB;AAAA,EACA;AAAA,EACA;AAAA,EAEjB,YAAY,KAAc,OAAe,IAAI,OAAgB,OAAO;AAClE,UAAM;AACN,SAAK,MAAM;AACX,SAAK,OAAO,KAAK,KAAK;AACtB,SAAK,OAAO;AAAA,EACd;AACF;AAKO,MAAM,gBAAgB,gBAAgB;AAAA,EAI1B;AAAA,EAEjB,YAAY,KAAc;AACxB,UAAM;AACN,SAAK,MAAM;AAAA,EACb;AACF;AAKO,MAAM,aAAa,gBAAgB;AAAA,EACvB;AAAA,EACA;AAAA,EACA;AAAA,EAEjB,YACE,kBACA,OACA;AACA,UAAM;AAEN,QAAI,OAAO,qBAAqB,UAAU;AACxC,WAAK,OAAO;AAEZ,UAAI,OAAO;AACT,aAAK,QAAQ;AAAA,MACf;AAAA,IACF,WAAW,6BAAS,gBAAgB,GAAG;AACrC,WAAK,aAAa;AAAA,IACpB;AAAA,EACF;AACF;AAKO,MAAM,cAAoE,gBAAgB;AAAA,EAE9E;AAAA,EAEA;AAAA,EAEA;AAAA,EAKjB,YACE,aACA,wBACA,cACA;AACA,UAAM;AAEN,SAAK,YAAY;AAEjB,QAAI,iBAAiB,QAAW;AAC9B,WAAK,QAAQ;AACb,WAAK,aAAa;AAAA,IACpB,OAAO;AACL,WAAK,QAAQ;AACb,WAAK,aAAa;AAAA,IACpB;AAAA,EACF;AACF;",
  "names": []
}
