{
  "version": 3,
  "sources": ["../../src/utils/url.ts"],
  "sourcesContent": ["/* Connection string URL utils */\r\nimport path from 'path';\r\nimport url from 'url';\r\nimport pgConnectionString from 'pg-connection-string';\r\nimport type { Dialect, Options } from '../sequelize';\r\n\r\n/**\r\n * Parses a connection string into an Options object with connection properties\r\n *\r\n * @param connectionString string value in format schema://username:password@host:port/database\r\n */\r\nexport function parseConnectionString(connectionString: string): Options {\r\n  const urlParts = url.parse(connectionString, true);\r\n  const options: Options = {};\r\n  if (urlParts.protocol) {\r\n    let protocol = urlParts.protocol.replace(/:$/, '');\r\n    if (protocol === 'postgresql') {\r\n      protocol = 'postgres';\r\n    }\r\n\r\n    options.dialect = protocol as Dialect;\r\n  }\r\n\r\n  if (urlParts.hostname != null) {\r\n    options.host = urlParts.hostname;\r\n  }\r\n\r\n  if (urlParts.pathname) {\r\n    options.database = urlParts.pathname.replace(/^\\//, '');\r\n  }\r\n\r\n  if (urlParts.port) {\r\n    options.port = urlParts.port;\r\n  }\r\n\r\n  if (urlParts.auth) {\r\n    const authParts = urlParts.auth.split(':');\r\n    options.username = authParts[0];\r\n    if (authParts.length > 1) {\r\n      options.password = authParts.slice(1).join(':');\r\n    }\r\n  }\r\n\r\n  if (options.dialect === 'sqlite' && urlParts.pathname && !urlParts.pathname.startsWith('/:memory')) {\r\n    const storagePath = path.join(options.host!, urlParts.pathname);\r\n    options.storage = path.resolve(options.storage || storagePath);\r\n  }\r\n\r\n  if (urlParts.query) {\r\n    // Allow host query argument to override the url host.\r\n    // Enables specifying domain socket hosts which cannot be specified via the typical\r\n    // host part of a url.\r\n    if (urlParts.query.host) {\r\n      options.host = urlParts.query.host as string;\r\n    }\r\n\r\n    options.dialectOptions = urlParts.query as object;\r\n    if (urlParts.query.options) {\r\n      try {\r\n        const o = JSON.parse(urlParts.query.options as string);\r\n        options.dialectOptions.options = o;\r\n      } catch {\r\n        // Nothing to do, string is not a valid JSON\r\n        // an thus does not need any further processing\r\n      }\r\n    }\r\n  }\r\n\r\n  // For postgres, we can use this helper to load certs directly from the\r\n  // connection string.\r\n  if (options.dialect === 'postgres') {\r\n    options.dialectOptions = options.dialectOptions || {};\r\n    Object.assign(options.dialectOptions, pgConnectionString.parse(connectionString));\r\n  }\r\n\r\n  return options;\r\n}\r\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AACA,kBAAiB;AACjB,iBAAgB;AAChB,kCAA+B;AAQxB,+BAA+B,kBAAmC;AACvE,QAAM,WAAW,mBAAI,MAAM,kBAAkB,IAAI;AACjD,QAAM,UAAmB,CAAC;AAC1B,MAAI,SAAS,UAAU;AACrB,QAAI,WAAW,SAAS,SAAS,QAAQ,MAAM,EAAE;AACjD,QAAI,aAAa,cAAc;AAC7B,iBAAW;AAAA,IACb;AAEA,YAAQ,UAAU;AAAA,EACpB;AAEA,MAAI,SAAS,YAAY,MAAM;AAC7B,YAAQ,OAAO,SAAS;AAAA,EAC1B;AAEA,MAAI,SAAS,UAAU;AACrB,YAAQ,WAAW,SAAS,SAAS,QAAQ,OAAO,EAAE;AAAA,EACxD;AAEA,MAAI,SAAS,MAAM;AACjB,YAAQ,OAAO,SAAS;AAAA,EAC1B;AAEA,MAAI,SAAS,MAAM;AACjB,UAAM,YAAY,SAAS,KAAK,MAAM,GAAG;AACzC,YAAQ,WAAW,UAAU;AAC7B,QAAI,UAAU,SAAS,GAAG;AACxB,cAAQ,WAAW,UAAU,MAAM,CAAC,EAAE,KAAK,GAAG;AAAA,IAChD;AAAA,EACF;AAEA,MAAI,QAAQ,YAAY,YAAY,SAAS,YAAY,CAAC,SAAS,SAAS,WAAW,UAAU,GAAG;AAClG,UAAM,cAAc,oBAAK,KAAK,QAAQ,MAAO,SAAS,QAAQ;AAC9D,YAAQ,UAAU,oBAAK,QAAQ,QAAQ,WAAW,WAAW;AAAA,EAC/D;AAEA,MAAI,SAAS,OAAO;AAIlB,QAAI,SAAS,MAAM,MAAM;AACvB,cAAQ,OAAO,SAAS,MAAM;AAAA,IAChC;AAEA,YAAQ,iBAAiB,SAAS;AAClC,QAAI,SAAS,MAAM,SAAS;AAC1B,UAAI;AACF,cAAM,IAAI,KAAK,MAAM,SAAS,MAAM,OAAiB;AACrD,gBAAQ,eAAe,UAAU;AAAA,MACnC,QAAE;AAAA,MAGF;AAAA,IACF;AAAA,EACF;AAIA,MAAI,QAAQ,YAAY,YAAY;AAClC,YAAQ,iBAAiB,QAAQ,kBAAkB,CAAC;AACpD,WAAO,OAAO,QAAQ,gBAAgB,oCAAmB,MAAM,gBAAgB,CAAC;AAAA,EAClF;AAEA,SAAO;AACT;",
  "names": []
}
