{
  "version": 3,
  "sources": ["../src/model-internals.ts"],
  "sourcesContent": ["import NodeUtil from 'util';\r\nimport { EagerLoadingError } from './errors';\r\nimport { isModelStatic } from './utils/model-utils.js';\r\n\r\n// TODO: strictly type this file during the TS migration of model.js\r\n\r\n// The goal of this file is to include the different private methods that are currently present on the Model class.\r\n// This reduces the risk of having a user implement a static method with the same name as us in their Model subclass,\r\n// it also prevents accessing internal methods.\r\n\r\nexport function _validateIncludedElements(options: any, tableNames: any = {}) {\r\n  if (!isModelStatic(options.model)) {\r\n    throw new TypeError('options.model must be provided, and a Model subclass.');\r\n  }\r\n\r\n  const ModelSubclass = options.model;\r\n\r\n  options.includeNames = [];\r\n  options.includeMap = {};\r\n\r\n  /* Legacy */\r\n  options.hasSingleAssociation = false;\r\n  options.hasMultiAssociation = false;\r\n\r\n  if (!options.parent) {\r\n    options.topModel = options.model;\r\n    options.topLimit = options.limit;\r\n  }\r\n\r\n  options.include = options.include.map((include: any) => {\r\n    include = ModelSubclass._conformInclude(include, options.model);\r\n    include.parent = options;\r\n    include.topLimit = options.topLimit;\r\n\r\n    ModelSubclass._validateIncludedElement.call(options.model, include, tableNames, options);\r\n\r\n    if (include.duplicating === undefined) {\r\n      include.duplicating = include.association.isMultiAssociation;\r\n    }\r\n\r\n    include.hasDuplicating = include.hasDuplicating || include.duplicating;\r\n    include.hasRequired = include.hasRequired || include.required;\r\n\r\n    options.hasDuplicating = options.hasDuplicating || include.hasDuplicating;\r\n    options.hasRequired = options.hasRequired || include.required;\r\n\r\n    options.hasWhere = options.hasWhere || include.hasWhere || Boolean(include.where);\r\n\r\n    return include;\r\n  });\r\n\r\n  for (const include of options.include) {\r\n    include.hasParentWhere = options.hasParentWhere || Boolean(options.where);\r\n    include.hasParentRequired = options.hasParentRequired || Boolean(options.required);\r\n\r\n    if (include.subQuery !== false && options.hasDuplicating && options.topLimit) {\r\n      if (include.duplicating) {\r\n        include.subQuery = include.subQuery || false;\r\n        include.subQueryFilter = include.hasRequired;\r\n      } else {\r\n        include.subQuery = include.hasRequired;\r\n        include.subQueryFilter = false;\r\n      }\r\n    } else {\r\n      include.subQuery = include.subQuery || false;\r\n      if (include.duplicating) {\r\n        include.subQueryFilter = include.subQuery;\r\n      } else {\r\n        include.subQueryFilter = false;\r\n        include.subQuery = include.subQuery || include.hasParentRequired && include.hasRequired && !include.separate;\r\n      }\r\n    }\r\n\r\n    options.includeMap[include.as] = include;\r\n    options.includeNames.push(include.as);\r\n\r\n    // Set top level options\r\n    if (options.topModel === options.model && options.subQuery === undefined && options.topLimit) {\r\n      if (include.subQuery) {\r\n        options.subQuery = include.subQuery;\r\n      } else if (include.hasDuplicating) {\r\n        options.subQuery = true;\r\n      }\r\n    }\r\n\r\n    /* Legacy */\r\n    options.hasIncludeWhere = options.hasIncludeWhere || include.hasIncludeWhere || Boolean(include.where);\r\n    options.hasIncludeRequired = options.hasIncludeRequired || include.hasIncludeRequired || Boolean(include.required);\r\n\r\n    if (include.association.isMultiAssociation || include.hasMultiAssociation) {\r\n      options.hasMultiAssociation = true;\r\n    }\r\n\r\n    if (include.association.isSingleAssociation || include.hasSingleAssociation) {\r\n      options.hasSingleAssociation = true;\r\n    }\r\n  }\r\n\r\n  if (options.topModel === options.model && options.subQuery === undefined) {\r\n    options.subQuery = false;\r\n  }\r\n\r\n  return options;\r\n}\r\n\r\nexport function combineIncludes(a: any, b: any): any {\r\n  if (a == null) {\r\n    return b;\r\n  }\r\n\r\n  if (b == null) {\r\n    return a;\r\n  }\r\n\r\n  if (!Array.isArray(a) || !Array.isArray(b)) {\r\n    throw new TypeError('Includes should have already been normalized before calling this method, but it received something else than an array.');\r\n  }\r\n\r\n  const combinedIncludes = [...a];\r\n\r\n  for (const newInclude of b) {\r\n    const existingIndex = combinedIncludes.findIndex(include => {\r\n      if (!include.association || !newInclude.association) {\r\n        throw new TypeError('Include should have been normalized');\r\n      }\r\n\r\n      return include.association === newInclude.association;\r\n    });\r\n\r\n    if (existingIndex === -1) {\r\n      combinedIncludes.push(newInclude);\r\n      continue;\r\n    }\r\n\r\n    const ModelClass = newInclude.model;\r\n    // _assignOptions *must* be called on the class of the Include's Model,\r\n    //  otherwise the Include's includes won't be checked correctly.\r\n    ModelClass._assignOptions(combinedIncludes[existingIndex], newInclude);\r\n  }\r\n\r\n  return combinedIncludes;\r\n}\r\n\r\nexport function throwInvalidInclude(include: any): never {\r\n  throw new EagerLoadingError(`Invalid Include received. Include has to be either a Model, an Association, the name of an association, or a plain object compatible with IncludeOptions.\r\nGot ${NodeUtil.inspect(include)} instead`);\r\n}\r\n"],
  "mappings": "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",
  "names": []
}
